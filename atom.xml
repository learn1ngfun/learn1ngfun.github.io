<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZTF</title>
  
  <subtitle>Learn1ngFun</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-11T11:49:22.349Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Lary Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生日快乐</title>
    <link href="http://example.com/2021/02/13/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
    <id>http://example.com/2021/02/13/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</id>
    <published>2021-02-13T06:50:45.000Z</published>
    <updated>2021-02-11T11:49:22.349Z</updated>
    
    <content type="html"><![CDATA[<p>芜湖，又老一岁了，离朝气蓬勃的 20 岁越来越远，离而立之年越来越近。啧啧，难过。</p><p>没想到到了这个年纪混的还是那么差，回顾过去的一年总感觉无论做什么还是却了点运气。开心过，难过过，但更多应该是孤独吧。其实孤独是每个男人应该经历的，真的，因为你在孤独中会有更多独立时间去思考之前从未想过的事。但是副作用是，你会越来越觉得一个人真好。</p><p>在过去的一年中，疫情并没有消失（反而最近有点严重），工资和能力还是没有长进，还是没能找到一个可以一直陪着我的姑娘。嗯~有点小遗憾。不过我现在明确了很多方向，比如我现在应该朝着什么去努力，我想获取什么，如果获取后我应该以什么心态去迎接，如果失败了我是否能承受失利的后果，等等。。。消失了一段时间吧，不发朋友圈，很少弹琴（最近捡起来了）。不是说我什么也没做，或者装高冷，而是做了很多，但没有一件让自己骄傲的事。还是一如既往的喜欢安静，偶尔写写文章（技术），累了打打游戏或者去看小说。每天的生活虽然平淡但是却很紧巴。我现在在走一条身边人很少走的路，路上只有我一个人，有时候迷路了也没有向导，没有指南针，撞到了南墙，回头继续走。我不知道会不会走向成功，但这是我唯一的出路，也别无选择。在 2021 年已经为自己计划好了应该做什么，努力去拼就好了。</p><p>这段写感谢，感谢谁呢，家人呗。他们不催我找对象（说过但没用），相信我会成功完成自己的理想，支持我继续北漂。家里出了问题也不会第一时间告诉我，怕我分心吧。很感谢，很感谢。还有为数不多的几个兄弟，他们真的是我在北漂的一块糖，伤心难过了找他们去吃东西，谈话间总能发现新段子。可以聊技术，聊八卦，聊工作，聊人生，希望以后的每一天，都能和他们相伴。</p><p>涨了一岁后我并没有想走向从成熟，反而我想回到 20 岁的模样，自信有活力，不问世事。就像我置顶的微博一样：继续努力，不断奋斗   争取有趣，重新年轻。接下里的一年里我会继续努力搞技术，博客地址就在这呢，看完这篇您退后一下就可以看到我的技术博客，虽然最近更的少，但是我素材攒的可不少，只能这一阵儿快放假了，心里长草了。对于我的吉他呢，我准备出长视频了，短视频没发展，发了 16 个 视频（截止目前），只有 78 个赞，呸，一群不懂得欣赏艺术的人。会继续安安静静努力搞钱，如果搞到了，我立一个 flag：留长发，可能染个绿色。哈哈哈~</p><p>过生日了，就要开开心心，最近喜欢上一首歌，毛不易的《感觉自己是巨星》。<strong>有时候我感觉自己是一个巨星，年轻貌美有才华用也用不尽。</strong> 哈哈，生日快乐。</p><p>​                                                                                </p><p>​                                                                                                                                                2021.2.13/ 正月初四</p><p>​                                                                                                                                                                       张腾飞</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;芜湖，又老一岁了，离朝气蓬勃的 20 岁越来越远，离而立之年越来越近。啧啧，难过。&lt;/p&gt;
&lt;p&gt;没想到到了这个年纪混的还是那么差，回顾过去的一年总感觉无论做什么还是却了点运气。开心过，难过过，但更多应该是孤独吧。其实孤独是每个男人应该经历的，真的，因为你在孤独中会有更多独</summary>
      
    
    
    
    <category term="水" scheme="http://example.com/categories/%E6%B0%B4/"/>
    
    
    <category term="水文" scheme="http://example.com/tags/%E6%B0%B4%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>手写HashMap</title>
    <link href="http://example.com/2021/02/11/%E6%89%8B%E5%86%99HashMap/"/>
    <id>http://example.com/2021/02/11/%E6%89%8B%E5%86%99HashMap/</id>
    <published>2021-02-11T06:50:45.000Z</published>
    <updated>2021-02-11T11:44:52.911Z</updated>
    
    <content type="html"><![CDATA[<p>过年好，过年了给大家手写一个 HashMap 吧，祝大家牛年大吉，心仪的 Offer 通通到手。</p><p>首先定义接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CustomMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span>V value<span class="token punctuation">)</span><span class="token punctuation">;</span>    V <span class="token function">get</span> <span class="token punctuation">(</span>K key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义一个内部接口</span>    <span class="token comment" spellcheck="true">//可以根据Entry对象拿到这个对象的key和value</span>    <span class="token keyword">interface</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">{</span>        K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>实现低配版 HashMap</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">CustomMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Integer defaultLength <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义数组长度（定义成2的倍数）</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">float</span> defaultLoad <span class="token operator">=</span> <span class="token number">0.75F</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义负载因子(超过这个因子就会扩容)</span>    <span class="token keyword">private</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定一个数组，盛放Entry对象</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义一个常量，用来记录hashmap元素个数</span>    <span class="token keyword">public</span> <span class="token function">CustomHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>defaultLength<span class="token punctuation">,</span> defaultLoad<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">CustomHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">float</span> load<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal length"</span> <span class="token operator">+</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>load <span class="token operator">></span> <span class="token number">0.0F</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>load<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>defaultLoad <span class="token operator">=</span> load<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>defaultLength <span class="token operator">=</span> length<span class="token punctuation">;</span>            table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>defaultLength<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load: "</span> <span class="token operator">+</span> load<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">getIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> entry <span class="token operator">=</span> table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>entry <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>entry <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> entry<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> entry<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> defaultLength <span class="token operator">*</span> defaultLoad<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">getIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">foundValueByKey</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> V <span class="token function">foundValueByKey</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">foundValueByKey</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> entry<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">CustomMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>        K key<span class="token punctuation">;</span>        V value<span class="token punctuation">;</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next<span class="token punctuation">;</span>        <span class="token keyword">int</span> index<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录下标</span>        <span class="token function">Entry</span><span class="token punctuation">(</span>K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> inx<span class="token punctuation">)</span> <span class="token punctuation">{</span>            key <span class="token operator">=</span> k<span class="token punctuation">;</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>            index <span class="token operator">=</span> inx<span class="token punctuation">;</span>            next <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数组第一个元素的下一个元素</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> key<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getIndex</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//数值上等于key.hashCode() % length</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//hashmap扩容</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> defaultLength<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"transfer 扩容"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> table<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//src引用了旧的Entry数组</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> src<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//遍历旧的Entry数组</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">=</span> src<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//取得旧Entry数组的每个元素</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                src<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">getIndex</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//重新计算每个元素在数组中的位置</span>                    e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话)；</span>                    newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//将元素放在数组上</span>                    e <span class="token operator">=</span> next<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//访问下一个Entry链上的元素</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>        defaultLength <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> defaultLength<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//更新数组长度</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>OK，至此完毕，虽然过年了，还是不能忘记学习啊，加油，内卷少年们。</p><p>原文： <a href="https://my.oschina.net/u/3136014/blog/1377261">https://my.oschina.net/u/3136014/blog/1377261</a></p><p>put 方法略有修改。</p><p>线程池文章拖了快一个月了，明天总结好奉上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;过年好，过年了给大家手写一个 HashMap 吧，祝大家牛年大吉，心仪的 Offer 通通到手。&lt;/p&gt;
&lt;p&gt;首先定义接口&lt;/p&gt;
&lt;pre class=&quot; language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;t</summary>
      
    
    
    
    <category term="手写" scheme="http://example.com/categories/%E6%89%8B%E5%86%99/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线程池（一）</title>
    <link href="http://example.com/2021/01/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0(%E4%B8%80)/"/>
    <id>http://example.com/2021/01/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0(%E4%B8%80)/</id>
    <published>2021-01-19T06:50:45.000Z</published>
    <updated>2021-02-11T11:46:40.222Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天我们聊一下线程池，聊线程池前我们应该知道为什么用线程池。我们的程序几乎都是面向大众的，每个功能可能在某一时间段不止一个人在使用。我们也希望一个功能可以同时满足多个人的需求。就像回复消息一样，你以为你的女神只回复你一个人消息，其实你只是她池塘里的一条鱼而已，在回复你时，人家已经给其他“备胎” 发了消息。这样是不是理解了。但是频繁创建销毁线程是很消耗资源的，所以我们需要对资源进行反复利用；线程池还可以防止内存溢出，我们通过设置线程池的大小让线程池有了处理线程能力的边界，从而也保护了程序。于是线程池的概念就诞生了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常用的线程池的提交方式有两种，分别为 execute 和 submit，submit 底层调用的 execute。submit 可以提交 callable 和 runnable 类型的参数，它会将参数封装成 FutureTask 的进行提交，然后通过 Future 可以 get 获取线程执行结果。而 execute 只能提交 runnable 类型的参数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，线程池一共有 5 种，其中 2 种为定时类型的，不是我们这次讨论的目标。这次主要探讨另三种，分别为 newFixedThreadPool，newSingleThreadExecutor 和 newSingleThreadExecutor。而通过源码我们可以发现这一系列线程池都是套娃 ThreadPoolExecutor 方法的。所以搞清楚 ThreadPoolExecutor 才是弄懂线程池的关键。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是对于 ThreadPoolExecutor 源码的讨论我们先放到后面，主要先看一下这三种线程池的运行效率，顺便科普一下线程池的简单应用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService es1 <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorService es2 <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorService es3 <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            es1<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyTask</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//es2.execute(new MyTask(i));</span>            <span class="token comment" spellcheck="true">//es3.execute(new MyTask(i));</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家可以在自己的电脑上试一下，你会发现在这三种线程池中 newCachedThreadPool 效率是最快的，其次是 newFixedThreadPool，最后是 newCachedThreadPool。那么为什么会这样呢，我们可以看一下源码。</p><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//核心线程数限制</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//最大线程限制</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment" spellcheck="true">// 空闲线程存活时间</span>                              TimeUnit unit<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 时间单位</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span><span class="token comment" spellcheck="true">// 任务队列</span>                              ThreadFactory threadFactory<span class="token punctuation">,</span><span class="token comment" spellcheck="true">// 线程工程</span>                              RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 拒绝策略    </span>     <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                    60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过源代码我们可以看出 newCachedThreadPool 的 核心线程数为 0，最大线程数为 Integer.MAX_VALUE（即 2^31 - 1 = 2147483647，21亿多，没有哪台机器可以承受吧，所以可以理解为不受限制），然后线程的生命时长为 60s 重点是任务队列为 BlockingQueue。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么这里简单介绍一下 BlockingQueue。SynchronousQueue是一个不存储元素的队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。也就是说一次只能处理一个线程，那么它几乎就不占用内存。接下来我画了张图。</p><img src="/images/threadpool1/newCachedThreadPool.png" style="zoom:30%;"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图我们可以看出，线程池中的所有线程都是在非核心线程区创建的（由于核心线程区为 0），相当于假如我有100份工作，而我又能找到 100 个工人帮我去做，那么很快就可以完成，所以 newCachedThreadPool 比较快。而我们又知道，线程数和 cpu 息息相关。由于创建线程没有限制，那么所有的线程都在非核心线程区创建，CPU 会消耗大量性能去创建线程，所以 newCachedThreadPool 极有可能造成 CPU 100%。</p><p>我们接下来看一看 newFixedThreadPool。</p><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                   0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;核心线程数和最大线程数都是传入参数，空闲线程存活时间为 0s（keepAliveTime 为非核心线程使用完后会多久回收，由于这里没有设置非核心线程数，所以线程使用完不回收。），注意这个任务队列为 LinkedBlockingQueue。LinkedBlockingQueue 内部基于链表来存放元素，它如果不指定容量，默认为 Integer.MAX_VALUE，也就是无界队列。（通常用的时候会设置大小，而这里没设置，为默认值。）。所以我们知道为什么第二个例子会比第一个慢了吧，第一个是用 100 个线程去完成任务，而第二个只创建了 10 个。但是 newFixedThreadPool 也有个问题，由于没有设置 LinkedBlockingQueue 的初始大小，所以它会无限大，极有可能会造成 OOM。</p><img src="/images/threadpool1/newFixedThreadPool.png" style="zoom:30%;"><p>接下来我们看一下 newSingleThreadExecutor。</p><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>      <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                              0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                              <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了核心线程数和最大线程数为 1 以外，其他的和 newFixedThreadPool 一样。也就是说它是一个任务一个任务的进行，所以 newSingleThreadExecutor 是三个里最慢的。当然了，newSingleThreadExecutory 依然有发生 OOM 的问题。</p><p>你可能会发现，官方提供的方法都有问题，我们看一下阿里的开发手册是怎么说的。</p><img src="/images/threadpool1/ali.png"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;里面说的“通过 ThreadPoolExecutor” 的方式即<strong>自定义线程池</strong>。也是我们在面试中常遇见的一道面试题：“请说一下自定义线程池中参数的含义”。那七个我已经在上面 ThreadPoolExecutor 构造函数里标注了注释，详细内容下一篇总结线程源码时会说的。粗略地写一个和朋友交流，他们用到自定义线程池的配置吧。</p><pre class=" language-java"><code class="language-java"> ThreadPoolExecutor pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">// 自定义一个线程池</span>                <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// coreSize</span>                <span class="token number">4</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// maxSize</span>                <span class="token number">60</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 60s</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>                 <span class="token punctuation">,</span> Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>当请求任务不断的过来，而系统此时又处理不过来的时候，我们需要采取的策略是拒绝服务。RejectedExecutionHandler接口提供了拒绝任务处理的自定义方法的机会。在ThreadPoolExecutor中已经包含四种处理策略。</p><ul><li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。</li><li>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</li><li>手写</li><li>DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。</li></ul><p>除了JDK默认提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，自定义的方式很简单，直接实现RejectedExecutionHandler接口即可。 </p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这篇文章其实有点怪，但是没办法，因为我下一把篇会讲源码，所以有好多点一笔带过了。线程池（二）马上献上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天我们聊一下线程池，聊线程池前我们应该知道为什么用线程池。我们的程序几乎都是面向大众的，每个功能可能在某一时间段不止一个人在使用。我们也希望一个功能可以同时满足多个人的需求。就</summary>
      
    
    
    
    <category term="线程" scheme="http://example.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Future 源码浅析</title>
    <link href="http://example.com/2021/01/11/Future/"/>
    <id>http://example.com/2021/01/11/Future/</id>
    <published>2021-01-10T21:35:28.000Z</published>
    <updated>2021-01-10T21:39:54.295Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道在 JAVA 中一般通过继承 Thread 类或者实现 Runnable 接口两种方式来创建多线程。但是这两种方式有个缺陷，就是不能获取执行的结果。如果想获取结果需要运用 Callable 和 Future 接口来获取任务结果。由于我最近想看线程池源码，今天我们来学习和线程池有关的 Future。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>你可能想了解，Future 怎么就和线程池有关了呢？看个小例子。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ExecutorService threadPool <span class="token operator">=</span> Executor<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Future f01 <span class="token operator">=</span> threadPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RunnableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      f01<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Future f02 <span class="token operator">=</span> threadPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CallableTask</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    f02<span class="token punctuation">.</span>cancel<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">class</span> <span class="token class-name">RunnableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">class</span> <span class="token class-name">CallableTask</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>通过这个小例子，我们可以了解到当我在线程池提交了一个线程，然后我想对池中执行的线程进行一些操作（get、cancel），那么我们可以通过 Future 句柄。</p><p>那么开始源码阅读吧！！</p><h3 id="基础属性"><a href="#基础属性" class="headerlink" title="基础属性"></a>基础属性</h3><p>通过线程池 submit 的方式提交的 runnable/callable 会被包装成 futureTask</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 表示当前 task 的状态</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务尚未执行</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NEW          <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务正在结束，尚未完全结束，一种临界状态</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COMPLETING   <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务正常结束</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NORMAL       <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务执行过程中发生了异常，内部封装的 callable.run() 向上抛出异常</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCEPTIONAL  <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务被取消</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED    <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务中断中..</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTING <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务已中断</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTED  <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// submit(runnable/callable) runnable 使用适配器模式 伪装成 Callable 了</span>    <span class="token keyword">private</span> Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** 正常情况下：当前任务执行结束，outcome 保存执行结果，callable 返回值 */</span>    <span class="token comment" spellcheck="true">/** 非正常情况：callable 向上抛出异常，Outcome 保存异常*/</span>    <span class="token keyword">private</span> Object outcome<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// non-volatile, protected by state reads/writes</span>    <span class="token comment" spellcheck="true">/** 当前任务被线程执行期间，保存当前执行任务的线程对象引用    */</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> Thread runner<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 因为会有很多线程会 get 当前任务的结果，所以这里使用了一种类似 头插 头取的队列 数据结构</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> WaitNode waiters<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 始终指向头节点</span></code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>当参数为 callable 的时候又返回值我们是可以理解的，毕竟人家自带返回值；可 runnable 是个无返回值函数，那么当参数是 runnable 的时候是怎么获取的返回值呢？其实它什么都没有干，它是不会通过一系列计算智能地给我们返回结果的返回值，而是根据我们传进去的参数 result，它是什么类型就传什么类型。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 参数为 callable 的构造函数</span><span class="token keyword">public</span> <span class="token function">FutureTask</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> null<span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> callable<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将当前任务状态设置为 new</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">FutureTask</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">,</span> V result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用适配器模式将 runnable 转换为 callable 接口</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">callable</span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// ensure visibility of callable</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">callable</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RunnableAdapter</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">RunnableAdapter</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Runnable task<span class="token punctuation">;</span>    <span class="token keyword">final</span> T result<span class="token punctuation">;</span>    <span class="token function">RunnableAdapter</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>task <span class="token operator">=</span> task<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 最后返回的就是传进来的 result，其实它并不能把运算结果返回出来，其实是装杯的</span>      <span class="token comment" spellcheck="true">// 传进啥 返回啥</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h3><p>//submit(runnable/callable) -&gt; newTaskFor(runnable) -&gt; execute(task)   -&gt; pool</p><p>首先我们通过线程池将 runnable/callable 的参数提交（submit），提交过程通过 newTaskFor 将runnbale 转换成 task，最后 execute 将task 真正提交到 pool。了解了大致流程，我们再来说 run。将任务提交到线程池后，如果还没有达到核心线程数，那么会新开一个线程，而 run 就是入口；如果达到了，那么 FutureTask 就入队进入队尾，如果有空闲线程就会消费线程。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 任务执行入口    </span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//条件一：state != NEW 条件成立，说明当前task已经被执行过了 或者 被cancel 了，总之非NEW状态的任务，线程就不处理了。</span>              <span class="token comment" spellcheck="true">//条件二：通过 cas 的方式将当前线程赋值给 runnerOffset。如果失败，说明当前任务被其他线程抢占了。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span>            <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>                                         null<span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 当前 task 一定是 new 状态，而且当前线程也抢占 task 成功</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//callable 就是程序员自己封装逻辑的 callable 或者装饰后的 runnable</span>            Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 条件一：防止空指针</span>            <span class="token comment" spellcheck="true">// 条件二：防止外部线程 cancel 掉当前任务。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>                V result<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 结果引用</span>                <span class="token comment" spellcheck="true">// true 表示 callable.run 代码块执行成功  未抛出异常</span>                  <span class="token comment" spellcheck="true">// false 表示 callable.run 代码块执行失败 抛出异常</span>                <span class="token keyword">boolean</span> ran<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                      <span class="token comment" spellcheck="true">//调用程序员自己实现的 callable 或者 适配器装饰后的 runnable</span>                    result <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 执行成功</span>                    ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 说明程序员自己写的逻辑块有 bug</span>                    result <span class="token operator">=</span> null<span class="token punctuation">;</span>                    ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 设置异常，下面解析👇</span>                    <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                  <span class="token comment" spellcheck="true">// 如果正常结束,将结果设置到 outcome 中</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ran<span class="token punctuation">)</span>                    <span class="token function">set</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            runner <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> INTERRUPTING<span class="token punctuation">)</span>                <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>V v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用CAS方式设置当前任务状态为 完成中..</span>        <span class="token comment" spellcheck="true">//有没有可能失败呢？ 外部线程等不及了，直接在set执行CAS之前 将  task取消了。  很小概率事件。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span> COMPLETING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            outcome <span class="token operator">=</span> v<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将结果赋值给 outcome之后，马上会将当前任务状态修改为 NORMAL 正常结束状态。</span>            UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NORMAL<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//最起码得把get() 再此阻塞的线程 唤醒..</span>            <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">setException</span><span class="token punctuation">(</span>Throwable t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用CAS方式设置当前任务状态为 完成中..</span>        <span class="token comment" spellcheck="true">//触发条件：外部线程等不及了，直接在set执行CAS之前 将  task取消了。  很小概率事件。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span> COMPLETING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//引用的是 callable 向上层抛出来的异常。</span>            outcome <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将当前任务的状态 修改为 EXCEPTIONAL</span>            UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> EXCEPTIONAL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// final state</span>            <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException <span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取当前任务状态</span>      <span class="token comment" spellcheck="true">// 条件成立：说明当前任务未完成。</span>      <span class="token comment" spellcheck="true">// 调用 get 的外部线程会被阻塞在 get 方法上。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> COMPLETING<span class="token punctuation">)</span>        s <span class="token operator">=</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">report</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> 0L<span class="token punctuation">;</span>        WaitNode q <span class="token operator">=</span> null<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//表示当前线程 waitNode对象 有没有 入队/压栈</span>        <span class="token keyword">boolean</span> queued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 自旋</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 条件成立：说明当前线程是被其他线程使用中断方式喊醒的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 列中删除该节点并抛出InterruptedException异常,出队</span>                <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//假设当前线程是被其它线程 使用unpark(thread) 唤醒的话。会正常自旋，走下面逻辑。</span>            <span class="token comment" spellcheck="true">//获取当前任务最新状态</span>            <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 条件成立：说明当前任务已经有结果了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> COMPLETING<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// 条件成立：说明已经为当前线程创建过node 了，此时需要将 node.thread = null helpGC</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    q<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">return</span> s<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//条件成立：说明当前任务接近完成状态...这里让当前线程再释放cpu ，进行下一次抢占cpu。</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> COMPLETING<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cannot time out yet</span>                Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//条件成立：第一次自旋，当前线程还未创建 WaitNode 对象，此时为当前线程创建 WaitNode对象</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> null<span class="token punctuation">)</span>                q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//条件成立：第二次自旋，当前线程已经创建 WaitNode对象了，但是node对象还未入队</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queued<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// q.next = waiters</span>                  <span class="token comment" spellcheck="true">//当前线程node节点 next 指向 原 队列的头节点   waiters 一直指向队列的头！</span>                <span class="token comment" spellcheck="true">//cas方式设置waiters引用指向 当前线程node， 成功的话 queued == true 否则，可能其它线程先你一步入队了。</span>                queued <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span>                                                     q<span class="token punctuation">.</span>next <span class="token operator">=</span> waiters<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 第三次自旋 如果不带超时的 get 那么不会走到这个分支</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> state<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>                  <span class="token comment" spellcheck="true">//当前get操作的线程就会被park了。  线程状态会变为 WAITING状态，相当于休眠了..</span>                <span class="token comment" spellcheck="true">//除非有其它线程将你唤醒  或者 将当前线程 中断。</span>                LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>awaitDone()中有个死循环，每一次循环都会</p><ol><li>判断调用get()的线程是否被其他线程中断，如果是的话则在等待队列中删除对应节点然后抛出InterruptedException异常。</li><li>获取任务当前状态，如果当前任务状态大于COMPLETING则表示任务执行完成，则把thread字段置null并返回结果。</li><li>如果任务处于COMPLETING状态，则表示任务已经处理完成(正常执行完成或者执行出现异常)，但是执行结果或者异常原因还没有保存到outcome字段中。这个时候调用线程让出执行权让其他线程优先执行。</li><li>如果等待节点为空，则构造一个等待节点WaitNode。</li><li>如果第四步中新建的节点还没如队列，则CAS的把该节点加入waiters队列的首节点。</li><li>阻塞等待。</li></ol><p>假设当前state=NEW且waiters为NULL,也就是说还没有任何一个线程调用get()获取执行结果，这个时候有两个线程threadA和threadB先后调用get()来获取执行结果。再假设这两个线程在加入阻塞队列进行阻塞等待之前任务都没有执行完成且threadA和threadB都没有被中断的情况下(因为如果threadA和threadB在进行阻塞等待结果之前任务就执行完成或线程本身被中断的话，awaitDone()就执行结束返回了)，执行过程是这样的，以threadA为例:</p><ol><li>第一轮for循环，执行的逻辑是q == null,所以这时候会新建一个节点q。第一轮循环结束。</li><li>第二轮for循环，执行的逻辑是!queue，这个时候会把第一轮循环中生成的节点的netx指针指向waiters，然后CAS的把节点q替换waiters。也就是把新生成的节点添加到waiters链表的首节点。如果替换成功，queued=true。第二轮循环结束。</li><li>第三轮for循环，进行阻塞等待。要么阻塞特定时间，要么一直阻塞知道被其他线程唤醒。</li></ol><h3 id="report"><a href="#report" class="headerlink" title="report"></a>report</h3><p>report 单拉出来吧，要不代码块太长了</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> V <span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//正常情况下，outcome 保存的是callable运行结束的结果</span>        <span class="token comment" spellcheck="true">//非正常，保存的是 callable 抛出的异常。</span>        Object x <span class="token operator">=</span> outcome<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//条件成立：当前任务状态正常结束</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> NORMAL<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 返回 callable 运算结果</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>V<span class="token punctuation">)</span>x<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 被取消状态</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> CANCELLED<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CancellationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 执行到这里，说明 callable 接口实现中有 bug.</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Throwable<span class="token punctuation">)</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="finishCompletion"><a href="#finishCompletion" class="headerlink" title="finishCompletion()"></a>finishCompletion()</h3><p>根据前面的分析，不管是任务执行异常还是任务正常执行完毕，或者取消任务，最后都会调用finishCompletion()方法，该方法实现如下:</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert state > COMPLETING;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>WaitNode q<span class="token punctuation">;</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> waiters<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span> q<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      <span class="token comment" spellcheck="true">//获取当前node节点封装的 thread</span>                    Thread t <span class="token operator">=</span> q<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//条件成立：说明当前线程不为null</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        q<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//help GC</span>                          <span class="token comment" spellcheck="true">//唤醒当前节点对应的线程</span>                        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    WaitNode next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    q<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// unlink to help gc</span>                    q <span class="token operator">=</span> next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        callable <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// to reduce footprint</span>    <span class="token punctuation">}</span></code></pre><p>这个方法的实现比较简单，依次遍历waiters链表，唤醒节点中的线程，然后把callable置空。</p><p>被唤醒的线程会各自从awaitDone()方法中的LockSupport.park*()阻塞中返回，然后会进行新一轮的循环。在新一轮的循环中会返回执行结果(或者更确切的说是返回任务的状态)。</p><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>cancel() 方法用来取消异步任务的执行。如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false。如果任务还没有被执行，则会返回 true 并且异步任务不会被执行。如果任务已经开始执行了但是还没有执行完成，若 mayInterruptIfRunning 为 true，则会立即中断执行任务的线程并返回 true，若 mayInterruptIfRunning 为 false，则会返回 true 且不会中断任务执行线程。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//条件一：state == NEW 成立 表示当前任务处于运行中 或者 处于线程池 任务队列中..</span>        <span class="token comment" spellcheck="true">//条件二：成立：说明修改状态成功，可以去执行下面逻辑了，否则 返回false 表示cancel失败。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>state <span class="token operator">==</span> NEW <span class="token operator">&amp;&amp;</span>              UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span>                  mayInterruptIfRunning <span class="token operator">?</span> INTERRUPTING <span class="token operator">:</span> CANCELLED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// in case call to interrupt throws exception</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mayInterruptIfRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 执行当前 FutureTask 的线程，有可能现在是 null，是 null 的情况：当前任务在队列中，还没有线程获取到它呢。。</span>                    Thread t <span class="token operator">=</span> runner<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 条件成立：说明当前线程 runner，正在执行 task</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true">// 给runner 线程一个中断信号..</span>                        t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// final state</span>                      <span class="token comment" spellcheck="true">// 设置任务状态为 中断完成。</span>                    UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> INTERRUPTED<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 唤醒所有 get() 阻塞的线程</span>            <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>有个值得关注的问题就是当任务还在执行的时候用户调用cancel(true)方法能否真正让任务停止执行呢？<br>在前面的分析中我们直到，当调用cancel(true)方法的时候，实际执行还是Thread.interrupt()方法，而interrupt()方法只是设置中断标志位，如果被中断的线程处于sleep()、wait()或者join()逻辑中则会抛出InterruptedException异常。</p><p>因此结论是:cancel(true)<strong>并不一定能够停止正在执行的异步任务。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结下，其实FutureTask的实现还是比较简单的，当用户实现Callable()接口定义好任务之后，把任务交给其他线程进行执行。FutureTask内部维护一个任务状态，任何操作都是围绕着这个状态进行，并随时更新任务状态。任务发起者调用get*()获取执行结果的时候，如果任务还没有执行完毕，则会把自己放入阻塞队列中然后进行阻塞等待。当任务执行完成之后，任务执行线程会依次唤醒阻塞等待的线程。调用cancel()取消任务的时候也只是简单的修改任务状态，如果需要中断任务执行线程的话则调用Thread.interrupt()中断任务执行线程。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>FutureTask源码解析—linghu  <a href="https://www.cnblogs.com/linghu-java/p/8991824.html">https://www.cnblogs.com/linghu-java/p/8991824.html</a>     </p><p>B 站 ”小刘讲源码“–《硬核手撕 Java 线程池 FutureTask 源码》<a href="https://www.bilibili.com/video/BV13E411N7pp">https://www.bilibili.com/video/BV13E411N7pp</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们都知道在 JAVA 中一般通过继承 Thread 类或者实现 Runnable 接口两种方式来创建多线程。但是这两种方式有个缺陷，就是不能获取执行的结果。如果想获取结果需要运用 Callable 和 Future 接口来获取任务结果。由于我最近想看线程池源码，今天我们来</summary>
      
    
    
    
    <category term="线程" scheme="http://example.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Future 源码浅析</title>
    <link href="http://example.com/2021/01/11/Future%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>http://example.com/2021/01/11/Future%E7%9A%84%E5%89%AF%E6%9C%AC/</id>
    <published>2021-01-10T21:35:28.000Z</published>
    <updated>2021-01-10T21:39:54.295Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道在 JAVA 中一般通过继承 Thread 类或者实现 Runnable 接口两种方式来创建多线程。但是这两种方式有个缺陷，就是不能获取执行的结果。如果想获取结果需要运用 Callable 和 Future 接口来获取任务结果。由于我最近想看线程池源码，今天我们来学习和线程池有关的 Future。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>你可能想了解，Future 怎么就和线程池有关了呢？看个小例子。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ExecutorService threadPool <span class="token operator">=</span> Executor<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Future f01 <span class="token operator">=</span> threadPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RunnableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      f01<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Future f02 <span class="token operator">=</span> threadPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CallableTask</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    f02<span class="token punctuation">.</span>cancel<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">class</span> <span class="token class-name">RunnableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">class</span> <span class="token class-name">CallableTask</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>通过这个小例子，我们可以了解到当我在线程池提交了一个线程，然后我想对池中执行的线程进行一些操作（get、cancel），那么我们可以通过 Future 句柄。</p><p>那么开始源码阅读吧！！</p><h3 id="基础属性"><a href="#基础属性" class="headerlink" title="基础属性"></a>基础属性</h3><p>通过线程池 submit 的方式提交的 runnable/callable 会被包装成 futureTask</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 表示当前 task 的状态</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务尚未执行</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NEW          <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务正在结束，尚未完全结束，一种临界状态</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COMPLETING   <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务正常结束</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NORMAL       <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务执行过程中发生了异常，内部封装的 callable.run() 向上抛出异常</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCEPTIONAL  <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务被取消</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED    <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务中断中..</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTING <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务已中断</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTED  <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// submit(runnable/callable) runnable 使用适配器模式 伪装成 Callable 了</span>    <span class="token keyword">private</span> Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** 正常情况下：当前任务执行结束，outcome 保存执行结果，callable 返回值 */</span>    <span class="token comment" spellcheck="true">/** 非正常情况：callable 向上抛出异常，Outcome 保存异常*/</span>    <span class="token keyword">private</span> Object outcome<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// non-volatile, protected by state reads/writes</span>    <span class="token comment" spellcheck="true">/** 当前任务被线程执行期间，保存当前执行任务的线程对象引用    */</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> Thread runner<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 因为会有很多线程会 get 当前任务的结果，所以这里使用了一种类似 头插 头取的队列 数据结构</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> WaitNode waiters<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 始终指向头节点</span></code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>当参数为 callable 的时候又返回值我们是可以理解的，毕竟人家自带返回值；可 runnable 是个无返回值函数，那么当参数是 runnable 的时候是怎么获取的返回值呢？其实它什么都没有干，它是不会通过一系列计算智能地给我们返回结果的返回值，而是根据我们传进去的参数 result，它是什么类型就传什么类型。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 参数为 callable 的构造函数</span><span class="token keyword">public</span> <span class="token function">FutureTask</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> null<span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> callable<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将当前任务状态设置为 new</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">FutureTask</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">,</span> V result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用适配器模式将 runnable 转换为 callable 接口</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">callable</span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// ensure visibility of callable</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">callable</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RunnableAdapter</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">RunnableAdapter</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Runnable task<span class="token punctuation">;</span>    <span class="token keyword">final</span> T result<span class="token punctuation">;</span>    <span class="token function">RunnableAdapter</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>task <span class="token operator">=</span> task<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 最后返回的就是传进来的 result，其实它并不能把运算结果返回出来，其实是装杯的</span>      <span class="token comment" spellcheck="true">// 传进啥 返回啥</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h3><p>//submit(runnable/callable) -&gt; newTaskFor(runnable) -&gt; execute(task)   -&gt; pool</p><p>首先我们通过线程池将 runnable/callable 的参数提交（submit），提交过程通过 newTaskFor 将runnbale 转换成 task，最后 execute 将task 真正提交到 pool。了解了大致流程，我们再来说 run。将任务提交到线程池后，如果还没有达到核心线程数，那么会新开一个线程，而 run 就是入口；如果达到了，那么 FutureTask 就入队进入队尾，如果有空闲线程就会消费线程。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 任务执行入口    </span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//条件一：state != NEW 条件成立，说明当前task已经被执行过了 或者 被cancel 了，总之非NEW状态的任务，线程就不处理了。</span>              <span class="token comment" spellcheck="true">//条件二：通过 cas 的方式将当前线程赋值给 runnerOffset。如果失败，说明当前任务被其他线程抢占了。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span>            <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>                                         null<span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 当前 task 一定是 new 状态，而且当前线程也抢占 task 成功</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//callable 就是程序员自己封装逻辑的 callable 或者装饰后的 runnable</span>            Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 条件一：防止空指针</span>            <span class="token comment" spellcheck="true">// 条件二：防止外部线程 cancel 掉当前任务。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>                V result<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 结果引用</span>                <span class="token comment" spellcheck="true">// true 表示 callable.run 代码块执行成功  未抛出异常</span>                  <span class="token comment" spellcheck="true">// false 表示 callable.run 代码块执行失败 抛出异常</span>                <span class="token keyword">boolean</span> ran<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                      <span class="token comment" spellcheck="true">//调用程序员自己实现的 callable 或者 适配器装饰后的 runnable</span>                    result <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 执行成功</span>                    ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 说明程序员自己写的逻辑块有 bug</span>                    result <span class="token operator">=</span> null<span class="token punctuation">;</span>                    ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 设置异常，下面解析👇</span>                    <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                  <span class="token comment" spellcheck="true">// 如果正常结束,将结果设置到 outcome 中</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ran<span class="token punctuation">)</span>                    <span class="token function">set</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            runner <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> INTERRUPTING<span class="token punctuation">)</span>                <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>V v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用CAS方式设置当前任务状态为 完成中..</span>        <span class="token comment" spellcheck="true">//有没有可能失败呢？ 外部线程等不及了，直接在set执行CAS之前 将  task取消了。  很小概率事件。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span> COMPLETING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            outcome <span class="token operator">=</span> v<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将结果赋值给 outcome之后，马上会将当前任务状态修改为 NORMAL 正常结束状态。</span>            UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NORMAL<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//最起码得把get() 再此阻塞的线程 唤醒..</span>            <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">setException</span><span class="token punctuation">(</span>Throwable t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用CAS方式设置当前任务状态为 完成中..</span>        <span class="token comment" spellcheck="true">//触发条件：外部线程等不及了，直接在set执行CAS之前 将  task取消了。  很小概率事件。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span> COMPLETING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//引用的是 callable 向上层抛出来的异常。</span>            outcome <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将当前任务的状态 修改为 EXCEPTIONAL</span>            UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> EXCEPTIONAL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// final state</span>            <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException <span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取当前任务状态</span>      <span class="token comment" spellcheck="true">// 条件成立：说明当前任务未完成。</span>      <span class="token comment" spellcheck="true">// 调用 get 的外部线程会被阻塞在 get 方法上。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> COMPLETING<span class="token punctuation">)</span>        s <span class="token operator">=</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">report</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> 0L<span class="token punctuation">;</span>        WaitNode q <span class="token operator">=</span> null<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//表示当前线程 waitNode对象 有没有 入队/压栈</span>        <span class="token keyword">boolean</span> queued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 自旋</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 条件成立：说明当前线程是被其他线程使用中断方式喊醒的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 列中删除该节点并抛出InterruptedException异常,出队</span>                <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//假设当前线程是被其它线程 使用unpark(thread) 唤醒的话。会正常自旋，走下面逻辑。</span>            <span class="token comment" spellcheck="true">//获取当前任务最新状态</span>            <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 条件成立：说明当前任务已经有结果了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> COMPLETING<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// 条件成立：说明已经为当前线程创建过node 了，此时需要将 node.thread = null helpGC</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    q<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">return</span> s<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//条件成立：说明当前任务接近完成状态...这里让当前线程再释放cpu ，进行下一次抢占cpu。</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> COMPLETING<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cannot time out yet</span>                Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//条件成立：第一次自旋，当前线程还未创建 WaitNode 对象，此时为当前线程创建 WaitNode对象</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> null<span class="token punctuation">)</span>                q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//条件成立：第二次自旋，当前线程已经创建 WaitNode对象了，但是node对象还未入队</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queued<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// q.next = waiters</span>                  <span class="token comment" spellcheck="true">//当前线程node节点 next 指向 原 队列的头节点   waiters 一直指向队列的头！</span>                <span class="token comment" spellcheck="true">//cas方式设置waiters引用指向 当前线程node， 成功的话 queued == true 否则，可能其它线程先你一步入队了。</span>                queued <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span>                                                     q<span class="token punctuation">.</span>next <span class="token operator">=</span> waiters<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 第三次自旋 如果不带超时的 get 那么不会走到这个分支</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> state<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>                  <span class="token comment" spellcheck="true">//当前get操作的线程就会被park了。  线程状态会变为 WAITING状态，相当于休眠了..</span>                <span class="token comment" spellcheck="true">//除非有其它线程将你唤醒  或者 将当前线程 中断。</span>                LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>awaitDone()中有个死循环，每一次循环都会</p><ol><li>判断调用get()的线程是否被其他线程中断，如果是的话则在等待队列中删除对应节点然后抛出InterruptedException异常。</li><li>获取任务当前状态，如果当前任务状态大于COMPLETING则表示任务执行完成，则把thread字段置null并返回结果。</li><li>如果任务处于COMPLETING状态，则表示任务已经处理完成(正常执行完成或者执行出现异常)，但是执行结果或者异常原因还没有保存到outcome字段中。这个时候调用线程让出执行权让其他线程优先执行。</li><li>如果等待节点为空，则构造一个等待节点WaitNode。</li><li>如果第四步中新建的节点还没如队列，则CAS的把该节点加入waiters队列的首节点。</li><li>阻塞等待。</li></ol><p>假设当前state=NEW且waiters为NULL,也就是说还没有任何一个线程调用get()获取执行结果，这个时候有两个线程threadA和threadB先后调用get()来获取执行结果。再假设这两个线程在加入阻塞队列进行阻塞等待之前任务都没有执行完成且threadA和threadB都没有被中断的情况下(因为如果threadA和threadB在进行阻塞等待结果之前任务就执行完成或线程本身被中断的话，awaitDone()就执行结束返回了)，执行过程是这样的，以threadA为例:</p><ol><li>第一轮for循环，执行的逻辑是q == null,所以这时候会新建一个节点q。第一轮循环结束。</li><li>第二轮for循环，执行的逻辑是!queue，这个时候会把第一轮循环中生成的节点的netx指针指向waiters，然后CAS的把节点q替换waiters。也就是把新生成的节点添加到waiters链表的首节点。如果替换成功，queued=true。第二轮循环结束。</li><li>第三轮for循环，进行阻塞等待。要么阻塞特定时间，要么一直阻塞知道被其他线程唤醒。</li></ol><h3 id="report"><a href="#report" class="headerlink" title="report"></a>report</h3><p>report 单拉出来吧，要不代码块太长了</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> V <span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//正常情况下，outcome 保存的是callable运行结束的结果</span>        <span class="token comment" spellcheck="true">//非正常，保存的是 callable 抛出的异常。</span>        Object x <span class="token operator">=</span> outcome<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//条件成立：当前任务状态正常结束</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> NORMAL<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 返回 callable 运算结果</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>V<span class="token punctuation">)</span>x<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 被取消状态</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> CANCELLED<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CancellationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 执行到这里，说明 callable 接口实现中有 bug.</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Throwable<span class="token punctuation">)</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="finishCompletion"><a href="#finishCompletion" class="headerlink" title="finishCompletion()"></a>finishCompletion()</h3><p>根据前面的分析，不管是任务执行异常还是任务正常执行完毕，或者取消任务，最后都会调用finishCompletion()方法，该方法实现如下:</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert state > COMPLETING;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>WaitNode q<span class="token punctuation">;</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> waiters<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span> q<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      <span class="token comment" spellcheck="true">//获取当前node节点封装的 thread</span>                    Thread t <span class="token operator">=</span> q<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//条件成立：说明当前线程不为null</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        q<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//help GC</span>                          <span class="token comment" spellcheck="true">//唤醒当前节点对应的线程</span>                        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    WaitNode next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    q<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// unlink to help gc</span>                    q <span class="token operator">=</span> next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        callable <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// to reduce footprint</span>    <span class="token punctuation">}</span></code></pre><p>这个方法的实现比较简单，依次遍历waiters链表，唤醒节点中的线程，然后把callable置空。</p><p>被唤醒的线程会各自从awaitDone()方法中的LockSupport.park*()阻塞中返回，然后会进行新一轮的循环。在新一轮的循环中会返回执行结果(或者更确切的说是返回任务的状态)。</p><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>cancel() 方法用来取消异步任务的执行。如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false。如果任务还没有被执行，则会返回 true 并且异步任务不会被执行。如果任务已经开始执行了但是还没有执行完成，若 mayInterruptIfRunning 为 true，则会立即中断执行任务的线程并返回 true，若 mayInterruptIfRunning 为 false，则会返回 true 且不会中断任务执行线程。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//条件一：state == NEW 成立 表示当前任务处于运行中 或者 处于线程池 任务队列中..</span>        <span class="token comment" spellcheck="true">//条件二：成立：说明修改状态成功，可以去执行下面逻辑了，否则 返回false 表示cancel失败。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>state <span class="token operator">==</span> NEW <span class="token operator">&amp;&amp;</span>              UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span>                  mayInterruptIfRunning <span class="token operator">?</span> INTERRUPTING <span class="token operator">:</span> CANCELLED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// in case call to interrupt throws exception</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mayInterruptIfRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 执行当前 FutureTask 的线程，有可能现在是 null，是 null 的情况：当前任务在队列中，还没有线程获取到它呢。。</span>                    Thread t <span class="token operator">=</span> runner<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 条件成立：说明当前线程 runner，正在执行 task</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true">// 给runner 线程一个中断信号..</span>                        t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// final state</span>                      <span class="token comment" spellcheck="true">// 设置任务状态为 中断完成。</span>                    UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> INTERRUPTED<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 唤醒所有 get() 阻塞的线程</span>            <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>有个值得关注的问题就是当任务还在执行的时候用户调用cancel(true)方法能否真正让任务停止执行呢？<br>在前面的分析中我们直到，当调用cancel(true)方法的时候，实际执行还是Thread.interrupt()方法，而interrupt()方法只是设置中断标志位，如果被中断的线程处于sleep()、wait()或者join()逻辑中则会抛出InterruptedException异常。</p><p>因此结论是:cancel(true)<strong>并不一定能够停止正在执行的异步任务。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结下，其实FutureTask的实现还是比较简单的，当用户实现Callable()接口定义好任务之后，把任务交给其他线程进行执行。FutureTask内部维护一个任务状态，任何操作都是围绕着这个状态进行，并随时更新任务状态。任务发起者调用get*()获取执行结果的时候，如果任务还没有执行完毕，则会把自己放入阻塞队列中然后进行阻塞等待。当任务执行完成之后，任务执行线程会依次唤醒阻塞等待的线程。调用cancel()取消任务的时候也只是简单的修改任务状态，如果需要中断任务执行线程的话则调用Thread.interrupt()中断任务执行线程。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>FutureTask源码解析—linghu  <a href="https://www.cnblogs.com/linghu-java/p/8991824.html">https://www.cnblogs.com/linghu-java/p/8991824.html</a>     </p><p>B 站 ”小刘讲源码“–《硬核手撕 Java 线程池 FutureTask 源码》<a href="https://www.bilibili.com/video/BV13E411N7pp">https://www.bilibili.com/video/BV13E411N7pp</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们都知道在 JAVA 中一般通过继承 Thread 类或者实现 Runnable 接口两种方式来创建多线程。但是这两种方式有个缺陷，就是不能获取执行的结果。如果想获取结果需要运用 Callable 和 Future 接口来获取任务结果。由于我最近想看线程池源码，今天我们来</summary>
      
    
    
    
    <category term="线程" scheme="http://example.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>主从复制</title>
    <link href="http://example.com/2021/01/01/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2021/01/01/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2021-01-01T13:28:45.000Z</published>
    <updated>2021-01-01T13:29:00.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h3><p>将一台 Redis 主服务器上的数据复制到其他的从服务器上。前者称为主节点（master），后者称为从节点（slave），数据的复制时单向的，只能从主节点复制到从节点。</p><p>为什么需要主从复制功能呢？</p><p>1）读写分离</p><ul><li><p>读操作：主库、从库都可以接受；</p></li><li><p>写操作：首先到主库执行，然后主库将写操作同步给从库</p></li></ul><p>​       这样可以提升 Redis 的服务能力。</p><p>2）数据容灾</p><p>​       由于从服务器与主服务器数据保持同步，一旦主服务器宕机，可以立即请求切换到从服务器，从而避免 Redis服务中断。</p><h4 id="主从库同步"><a href="#主从库同步" class="headerlink" title="主从库同步"></a>主从库同步</h4><p>想了解主从库一致的问题，我们首先还要从主从库间第一次同步入手。</p><p>当我们启动多个 Redis 实例的时候，我们可以通过 <strong>replicaof</strong>（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系。</p><p>例如，现在有实例 1（172.16.19.3:6379）和 实例 2（172.16.19.5:7000），我们在实例 2 上执行以下命令后，实例 2 就变成了实例 1 的从库，并从实例 1 上复制数据。</p><blockquote><p>172.16.19.5:7000&gt; REOLICAOF  172.16.19.3  6379</p><p>OK</p></blockquote><p>接下来我们就要学习主从库间数据第一次同步的三个阶段。</p><img src="/images/redis/redis2/1.png">    <p><strong>第一阶段</strong>,是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p><p>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库 runID 和复制进度 offset 两个参数。</p><ul><li>runID，是每个 Redis 实例启动时都会自动生成一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为 “？”。</li><li>offset，此时设置为 -1，表示第一次复制。</li></ul><p><strong>第二阶段</strong>  ，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p><p><strong>第三个阶段</strong>，主库会把第二阶段执行过程中新收到的写命令，再发给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发送给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。  </p><p>扩展一下，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发送给从库。但是这个持久化操作（bgsave）是一个非常消耗资源的操作，如果主服务器和从服务器之间发生了时间较短的网络连接故障。恢复后，从服务器会重新连接到主服务器，并发送 sync 命令请求同步数据。这时候主服务器还需要进行全量持久化操作吗？显然是不需要。因此在 Redis 2.8 提出了新的主从复制解决方案。</p><ul><li>从服务器会记录已经从主服务器接收到的数据量（复制偏移量 offset）。</li><li>主服务器会维护一个复制缓冲区，记录自己已执行且待发送给从服务器的命令请求，同时还需要记录复制缓冲区起一个字节的复制偏移量。</li></ul><p>当从服务器连接到主服务器时会发送 psync 命令请求同步数据，主服务器判断该复制偏移量是否还包含在复制缓冲区；如果包含，则不需要执行持久化操作，直接向从服务器请发送复制缓冲区命令请求即可，这称为部分重同步；如果不包含，则需要执行持久化操作，同时将所有新执行的写命令缓存在复制缓冲区中，并重置复制缓冲区第一个字节的复制偏移量，这称为完整重同步。</p><h3 id="主-从-从-模式"><a href="#主-从-从-模式" class="headerlink" title="主-从-从 模式"></a>主-从-从 模式</h3><p>从上文你可以看到，一次全量复制中，对于主库来说。需要完成两个耗时的操作：生成RDB文件和传输RDB文件。如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于fork子进程生成RDB文件，进行数据全量同步。fork这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。因此，我们通过<strong>“主- 从-从 模式”</strong>将主库生成RDB和传输RDB的压力，以级联的方式分散到数据库上。</p><blockquote><p>replicaof   所选从库的 IP  所选从库的端口号</p></blockquote><p>其实说白了就是给从库选择从库，这样一来这些从库就会知道，在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这样就可以减轻主库上的压力，如下图所示：</p><img src="/images/redis/redis2/2.png" style="zoom:30%;">    <h3 id="主从库之间网络断了怎么办？"><a href="#主从库之间网络断了怎么办？" class="headerlink" title="主从库之间网络断了怎么办？"></a><strong>主从库之间网络断了怎么办？</strong></h3><p>在Redis2.8之前。如果主库在命令传播时出现了网络闪断，那么从库会和主库进行一次全量复制，开销很大。</p><p>从Redis2.8开始，网络断了之后，主从库会采取用增量复制的方式继续同步，增量复制只会把主从网络断连期间主库收到的命令同步给从库。</p><p>当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些写操作命令也写入 repl_backlog_buffer这个缓冲区。repl_backlog_buffer是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。</p><p>刚开始的时候，主库和从库的写读位置在一起，这算他们的起始位置。随着主库不断接受新的写操作，他在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说对应的偏移量就是master_repl_offset。主库接受的新写操作越多，这个值就会越大。<br>同样，从库在复制完写操作命令后，他在缓冲区的读位置也开始逐渐偏移刚才的起始位置，此时，从库已复制的偏移量slave_repl_offset也在不断增加。正常情况下，这两个偏移量基本相等。</p><img src="/images/redis/redis2/3.png" style="zoom:50%;">    <p>主从库的连接恢复之后，从库首先会给主库发送psync命令，并把自己当前的slave_repl_offset发给主库，主库会判断自己的master_repl_offset发给主库，主库会判断自己的master_repl_offset和slave_repl_offset之间的差距。</p><p>在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset会大于slave_repl_offset和master_repl_offset之间的命令操作同步给从库就行。</p><p>不过，还有个地方需要强调一下，因为repl_backlog_buffer是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还没读取的操作被主库新的写操作覆盖了，这就会导致主从库间的数据不一致。因此我们要想办法避免这一情况，一般而言，我们可以调整repl_bacjlog_size这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：<strong>缓冲空间大小=主库写入命令速度 * 操作大小-主从库间网络传输命令速度 * 操作大小</strong>。再实际应用中，考虑到可能存在一些突发请求压力，我们通常需要把这个缓冲空间扩大一倍，即 <u>repl_backlog_size = 缓冲空间大小 * 2</u>，这也就是repl_bavklog_size的最终值。</p><p>举个例子，如果主库每秒写入 2000 个操作，每个操作的大小为 2KB，网络每秒能传输 1000 操作，那么，有 1000 个操作需要缓冲起来，这就至少需要 2MB 的缓冲空间。否则，新写的命令就会覆盖到旧操作了。为了应付可能的突发压力，我们最终把 repl_backlog_size 设为 4MB。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇主要讲解了主从复制的概念与原理，还引入“主-从-从”的概念和断网后 Redis 如何操作。相信大家对主从复制有可较深的印象，接下来会继续补充和收集关于一致性、哨兵和集群等方面的知识，希望大家能够喜欢。如果后续有时间或者需要我会将主从的源码补充。</p><p>祝大家 2021 新年快乐！！</p><p>最后文章的资料来源：</p><p>​                                                                                                                            极客时间—-《Redis 核心技术与实战》</p><p>​                                                                                                                    《Redis 5设计与源码分析》—- 陈雷 等编著</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是主从复制&quot;&gt;&lt;a href=&quot;#什么是主从复制&quot; class=&quot;headerlink&quot; title=&quot;什么是主从复制&quot;&gt;&lt;/a&gt;什么是主从复制&lt;/h3&gt;&lt;p&gt;将一台 Redis 主服务器上的数据复制到其他的从服务器上。前者称为主节点（master），后者称为</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="http://example.com/2020/12/29/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2020/12/29/%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-12-28T21:34:42.000Z</published>
    <updated>2021-02-11T11:51:25.108Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=472137696&auto=1&height=66"></iframe><h3 id="1-Spring-事务（20201229）"><a href="#1-Spring-事务（20201229）" class="headerlink" title="1. Spring 事务（20201229）"></a>1. Spring 事务（20201229）</h3><h4 id="1-1-Spring-事务中的隔离级别有哪几种？"><a href="#1-1-Spring-事务中的隔离级别有哪几种？" class="headerlink" title="1.1 Spring 事务中的隔离级别有哪几种？"></a>1.1 Spring 事务中的隔离级别有哪几种？</h4><ul><li>TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，Mysql 默认采用 REPEATABLE_READ 隔离级别，Oracle 默认采用的 READ_COMMITTED 隔离级别。</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、欢度或不可重复读</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复度仍可能发生</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事物之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这样将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h4 id="1-2-Spring-事务传播机制类型"><a href="#1-2-Spring-事务传播机制类型" class="headerlink" title="1.2 Spring 事务传播机制类型"></a>1.2 Spring 事务传播机制类型</h4><p>① PROPAGATION_REQUIRED</p><ul><li>支持当前事务，如果当前没有事务，则新建事务</li><li>如果当前存在事务，则加入当前事务，合并成一个事务</li></ul><p>② REQUIRES_NEW</p><ul><li>新建事务，如果当前存在事务，则把当前事务挂起</li><li>不受调用者的事物影响，父级异常，它也是正常提交</li></ul><p>③ SUPPORTS</p><ul><li>如果当前存在事务，则加入事务</li><li>不存在事务，则以非事务方式运行</li></ul><p>④ NOT_SUPPORTED</p><ul><li>以非事务方式运行</li><li>如果当前存在事务，则把当前事务挂起</li></ul><p>⑤ MANDATORY</p><ul><li>如果当前存在事务，则运行在当前事务中</li><li>如果当前无事务，则抛出异常，即父级方法必须有事务</li></ul><p>⑥ NEVER</p><ul><li>以非事务方式运行，如果当前存在事务，则抛出异常，即父级方法必须无事务</li></ul><p>⑦ NESTED</p><ul><li><p>如果当前存在事务，他会将成为父级事物的一个子事务，方法结束后并没有提交，只有等父事务结束了才提交</p></li><li><p>如果当前没事务，则新建事务</p></li><li><p>如果它异常，父级可以捕获它的异常而不进行混滚，正常提交</p></li></ul><p>参考：<a href="https://segmentfault.com/a/1190000020386113?utm_source=tag-newest">https://segmentfault.com/a/1190000020386113?utm_source=tag-newest</a></p><h3 id="2-TCP-和-UDP-的区别"><a href="#2-TCP-和-UDP-的区别" class="headerlink" title="2. TCP 和 UDP 的区别"></a>2. TCP 和 UDP 的区别</h3><p>UDP 在传输数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、QQ 视频、直播等等。</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制，在数据传完后，还会断开连接来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景 。</p><h3 id="3-HTTP-与-HTTPS-的区别"><a href="#3-HTTP-与-HTTPS-的区别" class="headerlink" title="3. HTTP 与 HTTPS 的区别"></a>3. HTTP 与 HTTPS 的区别</h3><ol><li>端口：HTTP 的 URL 由 “http://” 其实且默认使用端口 80，而 HTTPS 的 URL 由“https://” 起始且默认使用端口 443。</li><li>安全性和资源消耗： HTTP 协议运行在 TCP 之上，所有传输内容都是明文，客户端和服务器端都是无法验证对方身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都是经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP耗费更多服务器资源。</li></ol><h3 id="4-Redis-的过期淘汰策略"><a href="#4-Redis-的过期淘汰策略" class="headerlink" title="4. Redis 的过期淘汰策略"></a>4. Redis 的过期淘汰策略</h3><p>1）全局的键空间选择性移除</p><ul><li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li><li>llkey-lru：在键空间中，移除最近最少使用的 key。</li><li>llkey-random：在键空间中，随机移除某个 key。</li></ul><p>2）设置过期时间的键空间选择性移除</p><ul><li>volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的 key</li><li>olatile-random：在设置了过期时间的键空间中，随机移除某个 key</li><li>volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的 key 优先移除</li></ul><h3 id="5-缓存雪崩，击穿和穿透"><a href="#5-缓存雪崩，击穿和穿透" class="headerlink" title="5.缓存雪崩，击穿和穿透"></a>5.缓存雪崩，击穿和穿透</h3><p><strong>缓存雪崩</strong></p><p>缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层压力激增。</p><p>原因：</p><p>① 缓存中有大量数据同时过期，导致大量请求无法得到处理。</p><p>解决方案：</p><p>避免设置相同的过期时间</p><p>用 EXPIRE 命令给每个数据设置过期时间时，给这些数据的过期时间增加一个较小的随机数（随机增加 1~3 分钟）</p><p>通过降级来应对缓存雪崩</p><ul><li>当业务访问的是非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息，空值或者和是错误信息；</li><li>当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，可以继续通过数据库读取。</li></ul><p>这样一来，只有部分数据的请求会发送到数据库，数据库的压力就没有那么大了。</p><p>② Redis 缓存实例发生了宕机事故</p><p>是在业务系统中实现服务熔断或请求限流机制</p><p>熔断：暂停业务应用对缓存服务的访问，从而降低对数据库的访问压力。但这种方法对业务应用的影响较大。</p><p>我们也可以采用限流：比如原来每秒 1 万个请求，现在 1000 个</p><p><strong>缓存击穿</strong></p><p>缓存击穿是指，针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，姐姐这，访问数据的大量请求，一下子都发送到后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。</p><p>解决办法：</p><p>对于热点数据，我们不设置过期时间了。</p><p><strong>缓存穿透</strong></p><p>缓存穿透是指要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。此时，应用也无法从数据库中读取数据再写入缓存，来服务后续请求，这样一来，缓存也就成了 “摆设”，如果应用持续有大量请求访问数据，就会同时给缓存和数据库带来巨大压力。</p><p>发生情况：</p><ul><li>业务层误操作删除了，所以缓存和数据库中都没有数据；</li><li>恶意攻击</li></ul><p>解决办法</p><p>第一种</p><p>在 Redis 中缓存一个空值或是和业务协商确定的缺省值。如果后续发生了请求，将空值或者缺省值返回给业务应用。</p><p>第二种：</p><p>使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。</p><p>第三种：</p><p>在请求入口的前端进行请求检测。因为穿透的一个原因是有大量恶意请求访问不存在的数据，所以，一个有效的应对方案是在请求入口前端，把业务系统收到的请求进行合法检测，把恶意的请求直接过滤掉。</p><h3 id="6-select-count-时InnoDB-和-MyISAM-分别是怎么处理的。（）"><a href="#6-select-count-时InnoDB-和-MyISAM-分别是怎么处理的。（）" class="headerlink" title="6. select count(*) 时InnoDB 和 MyISAM 分别是怎么处理的。（）"></a>6. select count(*) 时InnoDB 和 MyISAM 分别是怎么处理的。（）</h3><p>在 MySQL 引擎中，count(*) 有不同的实现方式。</p><ul><li><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。</p></li><li><p>而 InnoDB 引擎在执行 count(*) 时候需要把数据一行一行地从引擎里面读出来，然后累积计数。</p></li></ul><p>注意：这里面套路的是没有过滤条件的 count(*) ，如果加了 where  条件的话，MyISAM 表也是不能返回得那么快。</p><p>原因：这个 Innodb 的事务设计有关系，可重复读是它的默认隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=</summary>
      
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Redis 持久化</title>
    <link href="http://example.com/2020/12/26/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://example.com/2020/12/26/redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-12-26T03:12:25.000Z</published>
    <updated>2020-12-26T09:11:57.467Z</updated>
    
    <content type="html"><![CDATA[<p>从所周知，Redis 的数据全部放在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 <strong>Redis 的持久化机制</strong>。</p><p>Redis 有两种持久化方式：一种为 <strong>RDB 方式</strong>，RDB 保存某一个时间点之前的数据；另一种为 <strong>AFO 方式</strong>，AOF保存的是 Redis 服务器端执行的每一条命令。</p><h3 id="快照-RDB"><a href="#快照-RDB" class="headerlink" title="快照 RDB"></a>快照 RDB</h3><p>RDB 快照有两种触发方式，其一<strong>通过配置参数</strong>，例如在配置文件中写入如下配置：</p><blockquote><p>save  60  1000</p></blockquote><p>在 60 秒内如果有 1000 个 key 发生变化，就会触发一次 RDB 快照的执行。</p><p>其二是<strong>通过在客户端执行 bgsave 命令</strong> 显式触发一次 RDB 快照执行。（下图为 bgsave 的执行流程）                </p><img src="/images/redis/redis1/r1.png" style="zoom:30%;">                        <blockquote><p>SAVE  命令也可以用于生成 RDB 文件，不同的是 SASVE 会阻塞 Redis 服务器进程，直至 RDB 文件创建完毕</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们需要关注的问题是，在内存数据做快照时，这些数据还能被修改吗？如果我们在拍照片时被拍对象”动“了，那么我们拍到的照片是模糊的。假如一次快照时间是 20s，在时刻 t 给内存做快照。而在时刻 t + 5 时，一个还没被写入磁盘的内存数据 A 被修改为 B，那么就破坏了快照的完整性，因为 B 不是 t 时刻的状态。因此，和拍照类似，我们在做快照时不希望数据 ”动“，也就是不能被修改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可是如果在快照的时间里，Redis 不能处理这些数据的写操作，那么无疑会给业务服务造成巨大的影响，肯定是不能接受的。所以这个时候，Redis 就会如上图所示 fork 出一个子进程执行 rdbSave 函数进行实际的快照存储工作。其原理是借助操作系统提供的写时复制技术 （Copy On Write），在执行快照的同时，正常处理写操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么主线程和 bgsave 子进程相互不影响。但是如果主线程要修改一块数据，这个时候就会使用操作系统的 COW 机制来进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离开来，然后对这个复制的页面进行修改。这时子进程相应的页面时没有变化的，还是进程产生的那一瞬间的数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RDB 保存的是一个时间点的快照，那么如果 Redis 出现了故障，丢失的就是最后一次 RDB 执行的时间点到故障发生的时间间隔之内之内产生的数据。如果 Redis 数据量很大，QPS 很高，那么故障发生时丢失的数据也会增多。那么如何解决这个由 RDB 本质引发的问题呢？请往下看。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AOF 就是将 Redis 服务端执行过的每一条命令都保存到一个文件，这样当Redis 重启时只要按照顺序回放这些命令就会恢复到原始状态。而 AOF 保存的是一条条命令，理论上可以做到发生故障时只丢失一条命令。那么如何开启 AOF 呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们要修改 Redis 的配置文件 <strong>redis.conf</strong>，找到 <strong>appendonly</strong>，将该值的 no 该写为 yes。退出后重启 Redis，就会发现 Redis bin 目录下有一个 appendonly.aof 文件，证明 AOF 持久化开启成功。</p><p><strong>AOF 日志是由主线程来完成的。</strong></p><p>下图为 AOF  持久化的过程。</p><img src="/images/redis/redis1/aof1.png" style="zoom:50%;">    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 AOF 持久化功能处于打开状态时，服务器在执行一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。aof_buf 是个全局的 SDS 类型的缓冲区。AOF 持久化最终需要将缓冲区中的内容写入一个文件，也就是 AOF 写入。</p><h4 id="AOF-文件写入"><a href="#AOF-文件写入" class="headerlink" title="AOF 文件写入"></a>AOF 文件写入</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写文件通过操作系统提供的 write 函数执行。但是 write 之后数据只是保存在 kernel 的缓冲区，真正写入磁盘还需要调用 fsync 函数。fsync 是一个阻塞并且缓慢的操作，所以 Redis 通过 appendfsync 配置控制执行 fsync 的频率。具体有如下 3 种写回策略。</p><ul><li>no：不执行 fsync，由操作系统负责数据的刷盘。数据安全性最低但 Redis 性能最高。</li><li>always：每次执行写入就会执行一次 fsync。数据安全性最高但会导致 Redis 性能降低。</li><li>everysec：每 1 秒执行一次 fsync 操作。属于折中方案，在数据安全和性能之间达到一个平衡。</li></ul><p>生产环境一般配置为 <strong>appendfsync  everysec</strong>。下面是三种写回策略的图片总结，方便大家理解。</p><img src="/images/redis/redis1/aof3.png" style="zoom:50%;"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们以 Redis 收到”set testkey  testvalue“ 命令后记录的日志为例，看看 AOF 日志的内容。其中，”*3“ 表示当前命令有三个部分，每部分都是由”$ + 数字“ 开头。例如，”$3 set“  表示这部分有3个字节，也就是”set” 命令；”$7 testkey“ 表示这部分有 7 个字节，也就是 ”testkey“ 等等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上解决 AOF 从命令追加到写入 AOF 日志文件，但是随着 Redis 使用频率的增加，我们可能会进行大量的操作，那么就会有大量的命令。大量的命令会使 AOF 日志文件增大，并且随着 AOF 文件的增大，读取日志文件的时间也会拉长。针对这个问题，我们便推出了一个新的概念 <strong>AOF 重写</strong>。</p><h4 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h4><p>AOF 重写通过主线程 <strong>fork</strong> 出一个子进程 bgerwriteaof 来执行。就是将多条命令变为一条命令，例如：</p><p>6379&gt; rpush list 1 2 3</p><p>(Integer) 3</p><p>6379&gt;  rpush list 4           // list 中 增加 4</p><p>(integer) 4 </p><p>6379&gt;  rpush  list  5         // list 中增加 5</p><p>(integer) 5</p><p>6379&gt;  lpop   list               // 弹出第一个元素</p><p>那么 AOF 会保存对 list 操作的 4 条命令</p><p>6379&gt; lrange list 0  -1          // 输出 list 中所有元素</p><p>4 条命令变为一条命令，可以减小文件大小，又可以提高加载速度。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而fork 出一个子进程来执行的目的是创建一个新 AOF 文件的任务会进行大量的写入操作，会长时间阻塞主线程，而在这期间可能无法处理客户端发来的命令请求。这是 Redis 所不希望的，因此重写操作会交给子进程来执行。（在 fork 的一瞬间也是会阻塞主线程的。）</p><h4 id="AOF-重写触发方式"><a href="#AOF-重写触发方式" class="headerlink" title="AOF 重写触发方式"></a>AOF 重写触发方式</h4><p>有两种触发方式：一是<strong>通过配置自动触发</strong>，一种为<strong>手动执行 bgrewriteaof 命令显式触发</strong>。首先来看自动触发方式。</p><blockquote><p>auto-aof-rewrite-percentage    100</p><p>auto-aof-rewrite-min-size   64mb</p></blockquote><p>解释：当 AOF 文件大于 64MB 时，并且 AOF 文件当前大小比基准大小增长了 100% 时会触发一次 AOF 重写。通常啊，生产上会将 auto-aof-rewrite-min-size 至少设置为 5G 左右。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重写日志出现问题就扔了。 重写日志的时候新的写命令会在缓冲区里面，等到重写完成了会发送信号给主线程，然后把缓冲区日志写到重写日志里面，就可以以新换旧了。由此可见，AOF 通过重写解决了文件膨胀的问题。随后，Redis 服务器可以创建一个新的 AOF 文件来替换现有的 AOF 文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，使用子进程也有一个问题需要处理，因为子进程在进行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对数据库状态进行修改。从而使得服务器当前的数据库状态和重写后的数据库状态不一致。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这种数据不一致问题，Redis 服务器设置了一个 AOF 重写缓冲区，如下图所示。</p><h4 id="AOF-后台重写"><a href="#AOF-后台重写" class="headerlink" title="AOF 后台重写"></a>AOF 后台重写</h4><p>在子进程执行 AOF 重写期间，服务器进程需要执行以下三个工作：</p><ul><li><p>执行客户端发来的命令</p></li><li><p>将执行后的命令追加到 AOF 缓冲区</p></li><li><p>在 fork 子进程的同时会把主线程的内存拷贝一份给 begrewriteaof 子进程。（这里的拷贝不是物理内存，而是子进程复制了父进程的页表，即虚实映射关系。fork 采用了操作系统系统的写时复制机制，就是为了避免一次性拷贝大量内存数据给子进程造成长时间阻塞问题。）</p></li></ul><p>当子进程完全 AOF 重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后会调用一个信号处理函数，并执行以下工作：</p><p>1）将 AOF  重写缓冲区中的所有内容写到新的 AOF 文件中，这时新 AOF 文件所保存的数据库状态和服务器当前的数据库状态一致。</p><p>2）对新的 AOF 文件进行改名，原子地覆盖所有的 AOF  文件，完成信就两个 AOF 文件的替换。</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>到这里 Redis 持久化就给大家总结完了，如果有什么讲的不仔细的可以给我提意见，我会认真修改的。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《Redis 设计与实现》—黄建宏 著</p><p>《Redis 5设计与源码分析》—- 陈雷 等编著</p><p>极客时间（Redis 核心技术与实战）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从所周知，Redis 的数据全部放在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 &lt;strong&gt;Redis 的持久化机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Redis 有两种持久化方式：一种为 &lt;st</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>重入锁 ReentrantLock 源码浅析（二）</title>
    <link href="http://example.com/2020/12/18/ReentrantLock2/"/>
    <id>http://example.com/2020/12/18/ReentrantLock2/</id>
    <published>2020-12-18T12:46:25.000Z</published>
    <updated>2020-12-18T08:27:51.621Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章主要讲了 ReentrantLock 的加锁和入队内容，今天我们来聊一聊释放锁和出队的内容。顺便带一下非公平锁，直接进入主题。</p><h3 id="AQS-释放锁逻辑"><a href="#AQS-释放锁逻辑" class="headerlink" title="AQS 释放锁逻辑"></a>AQS 释放锁逻辑</h3><h4 id="release-int-arg"><a href="#release-int-arg" class="headerlink" title="release(int arg)"></a>release(int arg)</h4><p>释放锁的调用关系</p><p>ReentrantLock.unpark() —&gt; sync.release() —&gt; AQS 提供的 relsese</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//尝试释放锁，为 true,则表示完全释放锁。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// head 什么时候会被创建出来</span>      <span class="token comment" spellcheck="true">// 当前线程未释放线程时，且持锁期间，有其他线程想要获取锁时，其他线程发现获取不到锁，</span>      <span class="token comment" spellcheck="true">// 而且队列是空队列，此时后续线程会为当前持锁中的线程构建出来一个 head 节点，</span>      <span class="token comment" spellcheck="true">// 然后后续线程会追加到 head 节点后面。</span>      Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 条件一：成立，说明队列中的head节点已经初始化过了，ReentrantLock 在使用期间发生过多线程竞争</span>      <span class="token comment" spellcheck="true">// 条件二：成立，说明当前head 后面一定插入过节点</span>      <span class="token comment" spellcheck="true">//（head 当开始初始化的时候是0，但是后面如果有节点插入则会将当前head节点的 ws 修改为 -1）</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 唤醒后继节点</span>        <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 减去释放的值..</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果当前线程并未持锁，直接异常。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前线程持有锁</span>    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是否已经完全释放锁</span>    <span class="token comment" spellcheck="true">// 只有当前线程的 state 值为 0，才是完全释放锁</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> free<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="unparkSuccessor-Node-node"><a href="#unparkSuccessor-Node-node" class="headerlink" title="unparkSuccessor(Node node)"></a>unparkSuccessor(Node node)</h4><p>AQS 中的 unparkSuccessor。</p><p>唤醒当前节点的下一个节点。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 改成 0 的原因：因为当前节点已经完成唤醒后继节点的任务了。</span>            <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当前节点的第一个后继节点</span>        Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         *什么时候 s 等于 null 呢         *1.当前节点就是 tail 节点时         *2.当节点未入队完成时         *  重述一遍入队过程：         *    ① 设置新节点的 prev 指向 pred         *    ② cas 这只新节点为 tail         *    ③ Pred.next 指向新节点（此处未完成）         *  当 ③ 还未完成时当前节点调用 release, 那么你拿到的 node.next 为 Null         *需要找到可以唤醒的节点         */</span>          <span class="token comment" spellcheck="true">//接下来看条件二</span>        <span class="token comment" spellcheck="true">//如果进入条件二，那么说明 s != null</span>        <span class="token comment" spellcheck="true">//说明 s 节点为取消状态，那么需要找一个合适的可以被唤醒的节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 查找可以被唤醒的节点</span>            s <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 从队尾遍历，会找到一个离当前 node 最近的一个可以被唤醒的 node，</span>            <span class="token comment" spellcheck="true">// node 可能找不到，node 可能是 null</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    s <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果找到合适的可以被唤醒的 node，则唤醒..找不到 什么也不做。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 总的来说一下上面三个方法。首先如果我们调用 ReentrantLock 的 unpark 方法，实际上我们就是调用 AQS的 release 方法。在 release 方法里我们首先会去尝试释放锁，什么时候算完全释放锁呢，当前线程的 state = 0的时候。如果当前 state 值为 0，那么如果当前线程不是空并且不是尾节点的话我们就会尝试唤醒后继节点。去阻塞队列里找到距离当前节点最近的，并且唤醒 waitStatus 小于等于 0 的节点。以上就是释放锁的大体逻辑。</p><h3 id="AQS-响应中断出队"><a href="#AQS-响应中断出队" class="headerlink" title="AQS 响应中断出队"></a>AQS 响应中断出队</h3><h4 id="cancelAcquire-Node-node"><a href="#cancelAcquire-Node-node" class="headerlink" title="cancelAcquire(Node node)"></a>cancelAcquire(Node node)</h4><p>取消指定 node 参与竞争</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 因为已经取消排队了，所以 node 内部关联的当前线程，置为 NULL 就好了</span>    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>    Node pred <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>      node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    Node predNext <span class="token operator">=</span> pred<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将当前node 状态设置为 取消状态 1</span>    node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> Node<span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * 当前取消排队的node 所在队列的位置不同，执行的出队策略是不一样的，一共分为三种情况：     * 1.当前 node 是队尾  tail -> node     * 2.当前 node 不是 head.next 节点，也不是 tail     * 3.当前 node 是 head.next 节点     */</span>    <span class="token comment" spellcheck="true">//条件一： node == tail  当前 Node 是队尾</span>    <span class="token comment" spellcheck="true">//条件二： 成功的话，说明修改 tail 完成</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 如果当前node 是队尾的话肯定要将 node 与前继节点断开然后尾指针指向前继节点</span>      <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> ws<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 当前 node 不是 head.next 节点，也不是 tail</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> head <span class="token operator">&amp;&amp;</span>          <span class="token comment" spellcheck="true">// 条件2.1：成立，说明 node 的前驱状态是 signal 状态</span>          <span class="token comment" spellcheck="true">//         不成立：前驱状态可能是 0 ，也可能是 1（前驱也取消排队..）</span>          <span class="token comment" spellcheck="true">// 条件2.2：假设前驱状态 &lt;= 0，则设置前驱状态为 Signal 状态..表示要唤醒后继节点。</span>          <span class="token comment" spellcheck="true">//if 里面：就是让 pred.next -> node.next，所以需要保证 pred 节点状态为 signal 状态</span>          <span class="token punctuation">(</span><span class="token punctuation">(</span>ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">)</span> <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL <span class="token operator">||</span>           <span class="token punctuation">(</span>ws <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>          pred<span class="token punctuation">.</span>thread <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 出队：pred.next -> node.next 节点后，当 node.next 节点被唤醒后</span>        <span class="token comment" spellcheck="true">// 调用 shouldParkAfterFailedAcquire 会让 node.next 节点越过取消状态的节点</span>        <span class="token comment" spellcheck="true">// 完成真正出队</span>        Node next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> next<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>          <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//当前 node 是 head.next 节点</span>        <span class="token comment" spellcheck="true">// 后继节点唤醒后，会调用 shouldParkAfterFailedAcquire 会让 node.next 节点越过取消状态的节点</span>        <span class="token comment" spellcheck="true">// 队列的第三个节点 会 直接与 head 建立 双重指向的关系：head.next -> 第三个 node 中间就是被出队                 //的 head.next 第三个 node.prev -> head(下面有简图)</span>        <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 指向自己，出队</span>      node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><img src="C:\Users\MrZhang\AppData\Roaming\Typora\typora-user-images\image-20201214212403096.png" alt="image-20201214212403096" style="zoom:0%;" /><h3 id="AQS-非公平锁"><a href="#AQS-非公平锁" class="headerlink" title="AQS 非公平锁"></a>AQS 非公平锁</h3><p>顺带说几嘴非公平锁，如果你理解了公平锁，非公平锁只是稍有不同。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 7316153563782823691L<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 上来就尝试加锁，也不管队列里有没有其他线程在等待，也不管当前状态有没有加锁。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 抢占成功设置独占</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果当前状态为0，它还是不判断当前队列里是否有等待线程，直接尝试抢锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没成功查看有没有重入</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 接下来都一样，该入队列入队列，该抢占资源抢占资源</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所以，非公平与公平锁就两点区别：① lock 的时候会先尝试抢一下锁，拿不到 调用 tryAquire；② 抢锁时都不去判断队列里是否有等待线程。其他流程一样。非公平锁时默认情况下的一种策略。</p><p>至此，AQS 的 ReentrantLock 的源码就分析完成了，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上篇文章主要讲了 ReentrantLock 的加锁和入队内容，今天我们来聊一聊释放锁和出队的内容。顺便带一下非公平锁，直接进入主题。&lt;/p&gt;
&lt;h3 id=&quot;AQS-释放锁逻辑&quot;&gt;&lt;a href=&quot;#AQS-释放锁逻辑&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="AQS" scheme="http://example.com/categories/AQS/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>重入锁 ReentrantLock 源码浅析（一）</title>
    <link href="http://example.com/2020/12/12/ReentrantLock/"/>
    <id>http://example.com/2020/12/12/ReentrantLock/</id>
    <published>2020-12-12T12:46:25.000Z</published>
    <updated>2020-12-13T10:45:16.334Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 除了使用关键字 synchronized 外，还使用了 ReentrantLock 实现独占、可重入锁的功能。相较于 synchronized，ReentrantLock 更为丰富和灵活。除此之外，我们或多或少还听说过一个名词 AQS。AQS 是Java 提供的底层同步工具，用一个 int 类型的变量表示同步状态，提供一系列的 CAS 操作来管理这个同步状态。我们今天的主角 ReentrantLock 也是基于 AQS 实现的。好的，废话少说，我们开始源码的探索路程。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先啊，我们打开源码就看到了 ReentrantLock 实现了 Lock 接口，那么 Lock 里面的一些加锁啊解锁啊等方法自然也要一一实现。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable </code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实ReentrantLock 就一个属性，那就是 sync。但 ReentrantLock 自己实现了一个 Sync 的静态内部类。这个 Sync 继承了 AbstractQueuedSynchronizer，也就是我们常说的 AQS。所以 AQS 中的一些重要属性自然而然也被ReentrantLock 继承。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进入 AbstractQueuedSynchronizer，我们依然可以看到里面也实现了一个静态内部类 Node。这个 Node 至关重要，它会出现在接下来的所有内容中。这次我只列举了ReentrantLock 需要用到的属性。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/** Marker to indicate a node is waiting in shared mode */</span>        <span class="token comment" spellcheck="true">/** 共享模式 */</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> Node SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** Marker to indicate a node is waiting in exclusive mode */</span>        <span class="token comment" spellcheck="true">/** 独占模式 */</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> Node EXCLUSIVE <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** waitStatus value to indicate thread has cancelled */</span>        <span class="token comment" spellcheck="true">/** 表示当前节点处于 取消 状态 */</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** waitStatus value to indicate successor's thread needs unparking */</span>        <span class="token comment" spellcheck="true">/** 表示当前节点需要唤醒后继节点 */</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** node 节点的状态 */</span>        <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** 因为需要构建双想链表，所以 prev 表示指向 node 节点的前一个节点*/</span>        <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** 指向 node 节点的后继节点*/</span>        <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** node 封装的线程 */</span>        <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** 阻塞队列的头节点 头节点对应的都是当前线程*/</span>        <span class="token comment" spellcheck="true">/** 这里的 head 并不是阻塞队列双向链表的 head，可以把 head.next 当做阻塞队列的开始         *  我在这里就犯了迷糊，在空队列的定义上犹豫了一会，所以这里给大家提个醒。          */</span>        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * Tail of the wait queue, lazily initialized.  Modified only via         * method enq to add new wait node.         */</span>        <span class="token comment" spellcheck="true">/** 阻塞队列的尾节点 */</span>        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * The synchronization state.         */</span>        <span class="token comment" spellcheck="true">// 表示资源</span>        <span class="token comment" spellcheck="true">// 独占模式：0 表示未加锁状态，>0 表示加锁状态</span>        <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReentrantLock 里面需要用到的属性就大致讲完了，其实还有一个状态码为 0 的，它代表当前节点是新建的节点。哦，对了，AbstractQueuedSynchronizer 还继承了一个抽象类 AbstractOwnableSynchronizer，里面的exclusiveOwnerThread 属性及其 get、set 方法也是重点对象。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 独占锁模式：表示当前独占锁线程</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Thread exclusiveOwnerThread<span class="token punctuation">;</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>     exclusiveOwnerThread <span class="token operator">=</span> thread<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">final</span> Thread <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> exclusiveOwnerThread<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>介绍完属性，接下来开始进入源码的阅读，这次主讲公平锁。先大致列举一下加锁阶段的方法。</p><p>lock()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt;acquire() 竞争资源</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; tryAquire() 尝试获取锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; acquireQueued()  挂起当前线程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; shouldParkAfterFailedAcquire()// 当前线程获取锁资源失败后是否需要挂起呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true: 需要；  false  不需要</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; parkAndCheckInterrupt()  挂起当前线程，唤醒之后返回当前线程的中断标记</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| –&gt; addWaiter()将当前线程封装成node</p><p>OK，大致骨架梳理完了，源码开始，gogogogo!!</p><h3 id="acquire-int-arg-–-加锁"><a href="#acquire-int-arg-–-加锁" class="headerlink" title="acquire(int arg) – 加锁"></a>acquire(int arg) – 加锁</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 公平锁入口，不响应中断的加锁</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 尝试获取锁，成功返回 true，失败返回 false.</span>    <span class="token comment" spellcheck="true">/* addWaiter 将当前线程封装成 node 入队     * acquireQueued 挂起当前线程      *               返回 true 表示挂起过程中线程被中断唤醒过     *                                返回 false 表示未被中断过     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>       <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，acquire() 就是竞争资源的方法，首先回去尝试获取锁，成功了就执行其业务逻辑，不成功会将其包装成Node进入阻塞队列中并挂起。</p><h3 id="tryAcquire-int-acquires-–-尝试获取锁"><a href="#tryAcquire-int-acquires-–-尝试获取锁" class="headerlink" title="tryAcquire(int acquires) – 尝试获取锁"></a>tryAcquire(int acquires) – 尝试获取锁</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取当前线程</span>    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// AQS state</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// state == 0 表示当前 AQS 处于无锁状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 条件1：hasQueuedPredecessors()          *       true：当前线程前面有等待者，当前线程需要入队等待         *       false：当前线程前面无等待者，直接尝试获取锁         * 条件2：通过 CAS 的方式设置 state         *       success：当前线程抢占锁成功         *       fail：存在竞争，且当前线程竞争失败         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//设置当前线程为独占者 线程</span>            <span class="token comment" spellcheck="true">// 注意：这里没有设置阻塞队列的 head 节点，后续在分析 addWaiter 的 enq 会提到</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// c != 0 需要检查当前线程是不是 独占锁的线程，因为ReentrantLock 是可重入的</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 更新值</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 越界判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 1.CAS 失败  c == 0 时，CAS 修改 sate时未抢过其他线程</span>    <span class="token comment" spellcheck="true">// 2. c > 0 且 ownerThread != currentThread.</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到 acquire方法，tryAcquire 如果返回 true 取反后为 false，就返回业务层面了。可如果tryAcquire 为 false，取反后为 true，那么就要进入阻塞队列挂起了。接下来我们看一下 addWaiter()。</p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将当前节点封装到 node 中</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Try the fast path of enq; backup to full enq on failure</span>    Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 快速入队</span>    <span class="token comment" spellcheck="true">// 条件成立：表示队列里面有 node</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将node 的 prev 指向 pred</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过 cas 的方式将 node 入队</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 前置节点指向 node，完成双向绑定。</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 什么时候会执行到这里？</span>    <span class="token comment" spellcheck="true">//1. 当前队列是空队列 tail == null</span>    <span class="token comment" spellcheck="true">//2. cas 竞争入队失败</span>    <span class="token comment" spellcheck="true">// 完整入队</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，addWaiter 方法无非就是将当前线程封装成 node节点加入到阻塞队列队尾中。如果一切进展顺利即上面所说的“快速入队”。如果中间出现阻塞队列为空队列或者 cas 插入队尾失败的情况则进入完整入队。接下来我们分析一下完整入队 enq()。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 自旋入队，只有当前 node 入队成功后，才会跳出循环*/</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 队列为空队列         * 说明当前锁 被占用，且当前线程有可能是第一个获取锁失败的线程         * （为什么是有可能？因为当前时刻可能存在一批获取锁失败的线程.）         */</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Must initialize</span>            <span class="token comment" spellcheck="true">// 作为当前持锁线程的第一个后继线程</span>            <span class="token comment" spellcheck="true">// 1.因为当前持锁线程在获取锁时（tryAcquire），成功了，并没有向阻塞队列中添加</span>            <span class="token comment" spellcheck="true">//   任何元素,所以这里要通过 cas 方式给阻塞队列添加头节点。</span>            <span class="token comment" spellcheck="true">// 2.自己追加节点</span>            <span class="token comment" spellcheck="true">// 然后我们便开始进入下一轮循环，下一轮直接进入 else</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 由于阻塞队列中已经有我们之前创建的节点了，所以我们直接将node的 prev指向 tail</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 通过cas的方式将当前 node 设置成新的尾节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全入队也很好理解，其实就是主要解决 addWaiter 没有入队成功的情况。如果你是因为空队列入队失败，那么我们就自己创建一个头节点，如果你是由于 cas 竞争入队失败，那么我们就自选入队直至成功。</p><p>接下来是 acquireQueued() 了，我个人认为这个方法有点烦的，我会尽量复述清楚。</p><p>这里先简单梳理一下 acquireQueued 的骨架。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;acquireQueued</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; shouldParkAfterFailedAcquire</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; parkAndCheckInterrupt</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| –&gt; cancelAcquire</p><p>acquireQueued 做了什么呢？</p><ol><li>当前节点是否有被 park？ 没有，那么就挂起。</li><li>唤醒之后的逻辑。</li></ol><p>当然了，这个方法依然是 AQS的，两个参数分别代表：</p><p>   参数1：node 就是当前线程包装出来的 node，且当前时刻 已经入队成功..</p><p>   参数2：当前线程抢占资源成功后，设置 state 值时会用到。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// true 表示当前线程抢占锁成功，普通情况下【lock】 当前线程早晚会拿到锁</span>    <span class="token comment" spellcheck="true">// false 表示失败，需要执行出队操作</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当前线程是否会中断</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//自旋</span>            <span class="token comment" spellcheck="true">// 什么时候会执行这里呢 </span>            <span class="token comment" spellcheck="true">//1.进入 for 循环时，在线程尚未 park 前会执行</span>            <span class="token comment" spellcheck="true">//2.线程 park 之后被唤醒后，也会执行这里..</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取当期线程的前置节点</span>            <span class="token comment" spellcheck="true">//条件一：成立 则说明当前节点为 head.next 节点，head.next 节点在任何时候都有权去争夺锁</span>            <span class="token comment" spellcheck="true">//条件二：tryAcquire(arg)</span>            <span class="token comment" spellcheck="true">//成立：说明head对应的线程已经释放锁了，head.next 节点对应的线程正好取到锁</span>            <span class="token comment" spellcheck="true">//不成立：说明 head 对应的线程还没释放锁，head.next 仍然需要被park。然后又走到下面挂起的逻辑</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 拿到锁之后干什么？</span>                <span class="token comment" spellcheck="true">// 首先设置自己为 head节点</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 将前置节点的 next 引用置为nul。协助出队。</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                <span class="token comment" spellcheck="true">// 当前线程获取锁的过程中没有出现异常</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 返回当前线程的中断标记</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// shouldParkAfterFailedAcquire </span>            <span class="token comment" spellcheck="true">// 表示当前线程获取锁资源失败了是否需要挂起呢？</span>            <span class="token comment" spellcheck="true">// 返回值：true-> 当前线程需要挂起  false-> 不需要..</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token comment" spellcheck="true">//parkAndCheckInterrupt</span>                <span class="token comment" spellcheck="true">//挂起当前线程，并且唤醒之后 返回 当前线程的中断标记</span>                <span class="token comment" spellcheck="true">//唤醒：1.正常唤醒 其他线程 unpark 2.其他线程给当前挂起的线程一个中断信号</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="竞争逻辑"><a href="#竞争逻辑" class="headerlink" title="竞争逻辑"></a>竞争逻辑</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取前置节点的状态 （前面有写，建议翻看）</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 成立：前置节点是可以唤醒当前节点的，返回 true 后，parkAndCheckInterrupt park当前线程</span>    <span class="token comment" spellcheck="true">// 普通情况下，第一次来到 该方法 ws 不会是 -1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ws > 0 表示前置节点是 CANCELED 状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 唤醒 canceled 节点的条件是当前节点的前置节点的 ws 为-1</span>        <span class="token comment" spellcheck="true">// 那么这个 do while 循环就不断地向前找状态不大于 0 的节点</span>        <span class="token comment" spellcheck="true">// 那么 ws > 0 的节点会出队（下面有图，可以参考一下）</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果当前 node 前置节点的状态为 0，</span>        <span class="token comment" spellcheck="true">// 则会将当前线程 node 前置节点状态强制设置为 SINGNAL</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>总结：</p><ol><li>当前节点的前置节点是取消状态，第一次来到这个方法时会越过取消状态的节点，第二次会返回 true，然后 park 当前线程。</li><li>当前节点的前置节点状态是 0，当前线程会设置前置节点的状态为 -1，第二次自旋来到这个方法时，会返回true 然后 Park 当前线程。</li></ol><p>接下来是 parkAndCheckInterrupt（）</p><p>它是 AQS 的方法，park 当前线程 将当前线程挂起，唤醒后返回当前线程是否为中断信号唤醒。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="通篇总结"><a href="#通篇总结" class="headerlink" title="通篇总结"></a>通篇总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是这篇文章的全部内容了，最后在概述一遍做个总结吧，主要是想梳理一下所有的源码知识点，毕竟无论是面试还是与人讨论我们都要大致说一下，总不能上来就滴水不漏地将整体细节全部描述出来。</p><p>① 如果我们用的是公平锁，那么我们就要调用FairSync 的 lock() 。</p><p>② 然后 lock 调用 acquire，参数传入 1，设置 AQS的 state 的值。</p><p>③ 进入 acquire 我们首先要尝试拿到锁（tryAcquire）,怎么去尝试拿到锁呢？我们先是获取当前线程，通过当前线程获取当前线程的状态值（state），如果状态值为 0，说明现在是无锁状态。然后判断当前线程前面有没有线程在等待（hasQueuedPredecessors），如果没有那么就通过 cas 的方式去设置 state值（compareAndSetState）。如果设置 state 值成功了，说明我们抢占锁成功了。把当前线程设置成独占者线程（setExclusiveOwnerThread），然后就返回 true 了。如果锁重入了呢，更新 state 值，再次设置新的 state，最后返回 true;</p><p>④ 如果没有拿到锁，那么我们会将当前线程封装成一个 Node 节点，然后将这个节点添加到阻塞队列中。</p><p>⑤进入到阻塞队列中我们还要看看当前线程是否是 park 状态，如果不是那么就将其挂起。并且唤醒线程的逻辑也在这个方法里。但唤醒的逻辑要下次再讲。到此整个加锁的过程全部完成。</p><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>以上文献资料来自 B 站 ”<strong>小刘思源码</strong>“，在此感谢小刘老师。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java 除了使用关键字 synchronized 外，还使用了 ReentrantLock 实现独占、可重入锁的功能。相较于 synchronized，ReentrantLoc</summary>
      
    
    
    
    <category term="AQS" scheme="http://example.com/categories/AQS/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
</feed>
