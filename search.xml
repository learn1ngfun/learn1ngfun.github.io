<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>重入锁 ReentrantLock 源码浅析（二）</title>
    <url>/2020/12/18/ReentrantLock2/</url>
    <content><![CDATA[<p>上篇文章主要讲了 ReentrantLock 的加锁和入队内容，今天我们来聊一聊释放锁和出队的内容。顺便带一下非公平锁，直接进入主题。</p>
<h3 id="AQS-释放锁逻辑"><a href="#AQS-释放锁逻辑" class="headerlink" title="AQS 释放锁逻辑"></a>AQS 释放锁逻辑</h3><h4 id="release-int-arg"><a href="#release-int-arg" class="headerlink" title="release(int arg)"></a>release(int arg)</h4><p>释放锁的调用关系</p>
<p>ReentrantLock.unpark() —&gt; sync.release() —&gt; AQS 提供的 relsese</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//尝试释放锁，为 true,则表示完全释放锁。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// head 什么时候会被创建出来</span>
      <span class="token comment" spellcheck="true">// 当前线程未释放线程时，且持锁期间，有其他线程想要获取锁时，其他线程发现获取不到锁，</span>
      <span class="token comment" spellcheck="true">// 而且队列是空队列，此时后续线程会为当前持锁中的线程构建出来一个 head 节点，</span>
      <span class="token comment" spellcheck="true">// 然后后续线程会追加到 head 节点后面。</span>
      Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 条件一：成立，说明队列中的head节点已经初始化过了，ReentrantLock 在使用期间发生过多线程竞争</span>
      <span class="token comment" spellcheck="true">// 条件二：成立，说明当前head 后面一定插入过节点</span>
      <span class="token comment" spellcheck="true">//（head 当开始初始化的时候是0，但是后面如果有节点插入则会将当前head节点的 ws 修改为 -1）</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">// 唤醒后继节点</span>
        <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 减去释放的值..</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 如果当前线程并未持锁，直接异常。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 当前线程持有锁</span>
    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是否已经完全释放锁</span>
    <span class="token comment" spellcheck="true">// 只有当前线程的 state 值为 0，才是完全释放锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> free<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="unparkSuccessor-Node-node"><a href="#unparkSuccessor-Node-node" class="headerlink" title="unparkSuccessor(Node node)"></a>unparkSuccessor(Node node)</h4><p>AQS 中的 unparkSuccessor。</p>
<p>唤醒当前节点的下一个节点。</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 改成 0 的原因：因为当前节点已经完成唤醒后继节点的任务了。</span>
            <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 当前节点的第一个后继节点</span>
        Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/*
         *什么时候 s 等于 null 呢
         *1.当前节点就是 tail 节点时
         *2.当节点未入队完成时
         *  重述一遍入队过程：
         *    ① 设置新节点的 prev 指向 pred
         *    ② cas 这只新节点为 tail
         *    ③ Pred.next 指向新节点（此处未完成）
         *  当 ③ 还未完成时当前节点调用 release, 那么你拿到的 node.next 为 Null
         *需要找到可以唤醒的节点
         */</span>
          <span class="token comment" spellcheck="true">//接下来看条件二</span>
        <span class="token comment" spellcheck="true">//如果进入条件二，那么说明 s != null</span>
        <span class="token comment" spellcheck="true">//说明 s 节点为取消状态，那么需要找一个合适的可以被唤醒的节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 查找可以被唤醒的节点</span>
            s <span class="token operator">=</span> null<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 从队尾遍历，会找到一个离当前 node 最近的一个可以被唤醒的 node，</span>
            <span class="token comment" spellcheck="true">// node 可能找不到，node 可能是 null</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    s <span class="token operator">=</span> t<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果找到合适的可以被唤醒的 node，则唤醒..找不到 什么也不做。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span>
            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 总的来说一下上面三个方法。首先如果我们调用 ReentrantLock 的 unpark 方法，实际上我们就是调用 AQS的 release 方法。在 release 方法里我们首先会去尝试释放锁，什么时候算完全释放锁呢，当前线程的 state = 0的时候。如果当前 state 值为 0，那么如果当前线程不是空并且不是尾节点的话我们就会尝试唤醒后继节点。去阻塞队列里找到距离当前节点最近的，并且唤醒 waitStatus 小于等于 0 的节点。以上就是释放锁的大体逻辑。</p>
<h3 id="AQS-响应中断出队"><a href="#AQS-响应中断出队" class="headerlink" title="AQS 响应中断出队"></a>AQS 响应中断出队</h3><h4 id="cancelAcquire-Node-node"><a href="#cancelAcquire-Node-node" class="headerlink" title="cancelAcquire(Node node)"></a>cancelAcquire(Node node)</h4><p>取消指定 node 参与竞争</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 因为已经取消排队了，所以 node 内部关联的当前线程，置为 NULL 就好了</span>
    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>
    Node pred <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
      node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    Node predNext <span class="token operator">=</span> pred<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 将当前node 状态设置为 取消状态 1</span>
    node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> Node<span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/*
     * 当前取消排队的node 所在队列的位置不同，执行的出队策略是不一样的，一共分为三种情况：
     * 1.当前 node 是队尾  tail -> node
     * 2.当前 node 不是 head.next 节点，也不是 tail
     * 3.当前 node 是 head.next 节点
     */</span>
    <span class="token comment" spellcheck="true">//条件一： node == tail  当前 Node 是队尾</span>
    <span class="token comment" spellcheck="true">//条件二： 成功的话，说明修改 tail 完成</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 如果当前node 是队尾的话肯定要将 node 与前继节点断开然后尾指针指向前继节点</span>
      <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">int</span> ws<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 当前 node 不是 head.next 节点，也不是 tail</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> head <span class="token operator">&amp;&amp;</span>
          <span class="token comment" spellcheck="true">// 条件2.1：成立，说明 node 的前驱状态是 signal 状态</span>
          <span class="token comment" spellcheck="true">//         不成立：前驱状态可能是 0 ，也可能是 1（前驱也取消排队..）</span>
          <span class="token comment" spellcheck="true">// 条件2.2：假设前驱状态 &lt;= 0，则设置前驱状态为 Signal 状态..表示要唤醒后继节点。</span>
          <span class="token comment" spellcheck="true">//if 里面：就是让 pred.next -> node.next，所以需要保证 pred 节点状态为 signal 状态</span>
          <span class="token punctuation">(</span><span class="token punctuation">(</span>ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">)</span> <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL <span class="token operator">||</span>
           <span class="token punctuation">(</span>ws <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
          pred<span class="token punctuation">.</span>thread <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 出队：pred.next -> node.next 节点后，当 node.next 节点被唤醒后</span>
        <span class="token comment" spellcheck="true">// 调用 shouldParkAfterFailedAcquire 会让 node.next 节点越过取消状态的节点</span>
        <span class="token comment" spellcheck="true">// 完成真正出队</span>
        Node next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> next<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
          <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">//当前 node 是 head.next 节点</span>
        <span class="token comment" spellcheck="true">// 后继节点唤醒后，会调用 shouldParkAfterFailedAcquire 会让 node.next 节点越过取消状态的节点</span>
        <span class="token comment" spellcheck="true">// 队列的第三个节点 会 直接与 head 建立 双重指向的关系：head.next -> 第三个 node 中间就是被出队                 //的 head.next 第三个 node.prev -> head(下面有简图)</span>
        <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">// 指向自己，出队</span>
      node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<img src="C:\Users\MrZhang\AppData\Roaming\Typora\typora-user-images\image-20201214212403096.png" alt="image-20201214212403096" style="zoom:0%;" />



<h3 id="AQS-非公平锁"><a href="#AQS-非公平锁" class="headerlink" title="AQS 非公平锁"></a>AQS 非公平锁</h3><p>顺带说几嘴非公平锁，如果你理解了公平锁，非公平锁只是稍有不同。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 7316153563782823691L<span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 上来就尝试加锁，也不管队列里有没有其他线程在等待，也不管当前状态有没有加锁。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// 抢占成功设置独占</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果当前状态为0，它还是不判断当前队列里是否有等待线程，直接尝试抢锁</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 没成功查看有没有重入</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 接下来都一样，该入队列入队列，该抢占资源抢占资源</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所以，非公平与公平锁就两点区别：① lock 的时候会先尝试抢一下锁，拿不到 调用 tryAquire；② 抢锁时都不去判断队列里是否有等待线程。其他流程一样。非公平锁时默认情况下的一种策略。</p>
<p>至此，AQS 的 ReentrantLock 的源码就分析完成了，</p>
]]></content>
      <categories>
        <category>AQS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>重入锁 ReentrantLock 源码浅析（一）</title>
    <url>/2020/12/12/ReentrantLock/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 除了使用关键字 synchronized 外，还使用了 ReentrantLock 实现独占、可重入锁的功能。相较于 synchronized，ReentrantLock 更为丰富和灵活。除此之外，我们或多或少还听说过一个名词 AQS。AQS 是Java 提供的底层同步工具，用一个 int 类型的变量表示同步状态，提供一系列的 CAS 操作来管理这个同步状态。我们今天的主角 ReentrantLock 也是基于 AQS 实现的。好的，废话少说，我们开始源码的探索路程。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先啊，我们打开源码就看到了 ReentrantLock 实现了 Lock 接口，那么 Lock 里面的一些加锁啊解锁啊等方法自然也要一一实现。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable </code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实ReentrantLock 就一个属性，那就是 sync。但 ReentrantLock 自己实现了一个 Sync 的静态内部类。这个 Sync 继承了 AbstractQueuedSynchronizer，也就是我们常说的 AQS。所以 AQS 中的一些重要属性自然而然也被ReentrantLock 继承。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进入 AbstractQueuedSynchronizer，我们依然可以看到里面也实现了一个静态内部类 Node。这个 Node 至关重要，它会出现在接下来的所有内容中。这次我只列举了ReentrantLock 需要用到的属性。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/** Marker to indicate a node is waiting in shared mode */</span>
        <span class="token comment" spellcheck="true">/** 共享模式 */</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> Node SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** Marker to indicate a node is waiting in exclusive mode */</span>
        <span class="token comment" spellcheck="true">/** 独占模式 */</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> Node EXCLUSIVE <span class="token operator">=</span> null<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/** waitStatus value to indicate thread has cancelled */</span>
        <span class="token comment" spellcheck="true">/** 表示当前节点处于 取消 状态 */</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** waitStatus value to indicate successor's thread needs unparking */</span>
        <span class="token comment" spellcheck="true">/** 表示当前节点需要唤醒后继节点 */</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** node 节点的状态 */</span>
        <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** 因为需要构建双想链表，所以 prev 表示指向 node 节点的前一个节点*/</span>
        <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** 指向 node 节点的后继节点*/</span>
        <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** node 封装的线程 */</span>
        <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** 阻塞队列的头节点 头节点对应的都是当前线程*/</span>
        <span class="token comment" spellcheck="true">/** 这里的 head 并不是阻塞队列双向链表的 head，可以把 head.next 当做阻塞队列的开始
         *  我在这里就犯了迷糊，在空队列的定义上犹豫了一会，所以这里给大家提个醒。 
         */</span>
        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/**
         * Tail of the wait queue, lazily initialized.  Modified only via
         * method enq to add new wait node.
         */</span>
        <span class="token comment" spellcheck="true">/** 阻塞队列的尾节点 */</span>
        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/**
         * The synchronization state.
         */</span>
        <span class="token comment" spellcheck="true">// 表示资源</span>
        <span class="token comment" spellcheck="true">// 独占模式：0 表示未加锁状态，>0 表示加锁状态</span>
        <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReentrantLock 里面需要用到的属性就大致讲完了，其实还有一个状态码为 0 的，它代表当前节点是新建的节点。哦，对了，AbstractQueuedSynchronizer 还继承了一个抽象类 AbstractOwnableSynchronizer，里面的exclusiveOwnerThread 属性及其 get、set 方法也是重点对象。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 独占锁模式：表示当前独占锁线程</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> Thread exclusiveOwnerThread<span class="token punctuation">;</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     exclusiveOwnerThread <span class="token operator">=</span> thread<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> Thread <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> exclusiveOwnerThread<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>介绍完属性，接下来开始进入源码的阅读，这次主讲公平锁。先大致列举一下加锁阶段的方法。</p>
<p>lock()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt;acquire() 竞争资源</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; tryAquire() 尝试获取锁</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; acquireQueued()  挂起当前线程</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; shouldParkAfterFailedAcquire()// 当前线程获取锁资源失败后是否需要挂起呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true: 需要；  false  不需要</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; parkAndCheckInterrupt()  挂起当前线程，唤醒之后返回当前线程的中断标记</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| –&gt; addWaiter()将当前线程封装成node</p>
<p>OK，大致骨架梳理完了，源码开始，gogogogo!!</p>
<h3 id="acquire-int-arg-–-加锁"><a href="#acquire-int-arg-–-加锁" class="headerlink" title="acquire(int arg) – 加锁"></a>acquire(int arg) – 加锁</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 公平锁入口，不响应中断的加锁</span>
<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 尝试获取锁，成功返回 true，失败返回 false.</span>
    <span class="token comment" spellcheck="true">/* addWaiter 将当前线程封装成 node 入队
     * acquireQueued 挂起当前线程 
     *               返回 true 表示挂起过程中线程被中断唤醒过
     *                                返回 false 表示未被中断过
     */</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
       <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，acquire() 就是竞争资源的方法，首先回去尝试获取锁，成功了就执行其业务逻辑，不成功会将其包装成Node进入阻塞队列中并挂起。</p>
<h3 id="tryAcquire-int-acquires-–-尝试获取锁"><a href="#tryAcquire-int-acquires-–-尝试获取锁" class="headerlink" title="tryAcquire(int acquires) – 尝试获取锁"></a>tryAcquire(int acquires) – 尝试获取锁</h3><pre class=" language-java"><code class="language-java">
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获取当前线程</span>
    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// AQS state</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// state == 0 表示当前 AQS 处于无锁状态</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * 条件1：hasQueuedPredecessors() 
         *       true：当前线程前面有等待者，当前线程需要入队等待
         *       false：当前线程前面无等待者，直接尝试获取锁
         * 条件2：通过 CAS 的方式设置 state
         *       success：当前线程抢占锁成功
         *       fail：存在竞争，且当前线程竞争失败
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//设置当前线程为独占者 线程</span>
            <span class="token comment" spellcheck="true">// 注意：这里没有设置阻塞队列的 head 节点，后续在分析 addWaiter 的 enq 会提到</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// c != 0 需要检查当前线程是不是 独占锁的线程，因为ReentrantLock 是可重入的</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 更新值</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 越界判断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 1.CAS 失败  c == 0 时，CAS 修改 sate时未抢过其他线程</span>
    <span class="token comment" spellcheck="true">// 2. c > 0 且 ownerThread != currentThread.</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到 acquire方法，tryAcquire 如果返回 true 取反后为 false，就返回业务层面了。可如果tryAcquire 为 false，取反后为 true，那么就要进入阻塞队列挂起了。接下来我们看一下 addWaiter()。</p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 将当前节点封装到 node 中</span>
    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// Try the fast path of enq; backup to full enq on failure</span>
    Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 快速入队</span>
    <span class="token comment" spellcheck="true">// 条件成立：表示队列里面有 node</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将node 的 prev 指向 pred</span>
        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 通过 cas 的方式将 node 入队</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 前置节点指向 node，完成双向绑定。</span>
            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 什么时候会执行到这里？</span>
    <span class="token comment" spellcheck="true">//1. 当前队列是空队列 tail == null</span>
    <span class="token comment" spellcheck="true">//2. cas 竞争入队失败</span>

    <span class="token comment" spellcheck="true">// 完整入队</span>
    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，addWaiter 方法无非就是将当前线程封装成 node节点加入到阻塞队列队尾中。如果一切进展顺利即上面所说的“快速入队”。如果中间出现阻塞队列为空队列或者 cas 插入队尾失败的情况则进入完整入队。接下来我们分析一下完整入队 enq()。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/** 自旋入队，只有当前 node 入队成功后，才会跳出循环*/</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/*
         * 队列为空队列
         * 说明当前锁 被占用，且当前线程有可能是第一个获取锁失败的线程
         * （为什么是有可能？因为当前时刻可能存在一批获取锁失败的线程.）
         */</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Must initialize</span>
            <span class="token comment" spellcheck="true">// 作为当前持锁线程的第一个后继线程</span>
            <span class="token comment" spellcheck="true">// 1.因为当前持锁线程在获取锁时（tryAcquire），成功了，并没有向阻塞队列中添加</span>
            <span class="token comment" spellcheck="true">//   任何元素,所以这里要通过 cas 方式给阻塞队列添加头节点。</span>
            <span class="token comment" spellcheck="true">// 2.自己追加节点</span>
            <span class="token comment" spellcheck="true">// 然后我们便开始进入下一轮循环，下一轮直接进入 else</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 由于阻塞队列中已经有我们之前创建的节点了，所以我们直接将node的 prev指向 tail</span>
            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 通过cas的方式将当前 node 设置成新的尾节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
                <span class="token keyword">return</span> t<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全入队也很好理解，其实就是主要解决 addWaiter 没有入队成功的情况。如果你是因为空队列入队失败，那么我们就自己创建一个头节点，如果你是由于 cas 竞争入队失败，那么我们就自选入队直至成功。</p>
<p>接下来是 acquireQueued() 了，我个人认为这个方法有点烦的，我会尽量复述清楚。</p>
<p>这里先简单梳理一下 acquireQueued 的骨架。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;acquireQueued</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; shouldParkAfterFailedAcquire</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; parkAndCheckInterrupt</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| –&gt; cancelAcquire</p>
<p>acquireQueued 做了什么呢？</p>
<ol>
<li>当前节点是否有被 park？ 没有，那么就挂起。</li>
<li>唤醒之后的逻辑。</li>
</ol>
<p>当然了，这个方法依然是 AQS的，两个参数分别代表：</p>
<p>   参数1：node 就是当前线程包装出来的 node，且当前时刻 已经入队成功..</p>
<p>   参数2：当前线程抢占资源成功后，设置 state 值时会用到。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// true 表示当前线程抢占锁成功，普通情况下【lock】 当前线程早晚会拿到锁</span>
    <span class="token comment" spellcheck="true">// false 表示失败，需要执行出队操作</span>
    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 当前线程是否会中断</span>
        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//自旋</span>
            <span class="token comment" spellcheck="true">// 什么时候会执行这里呢 </span>
            <span class="token comment" spellcheck="true">//1.进入 for 循环时，在线程尚未 park 前会执行</span>
            <span class="token comment" spellcheck="true">//2.线程 park 之后被唤醒后，也会执行这里..</span>
            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取当期线程的前置节点</span>
            <span class="token comment" spellcheck="true">//条件一：成立 则说明当前节点为 head.next 节点，head.next 节点在任何时候都有权去争夺锁</span>
            <span class="token comment" spellcheck="true">//条件二：tryAcquire(arg)</span>
            <span class="token comment" spellcheck="true">//成立：说明head对应的线程已经释放锁了，head.next 节点对应的线程正好取到锁</span>
            <span class="token comment" spellcheck="true">//不成立：说明 head 对应的线程还没释放锁，head.next 仍然需要被park。然后又走到下面挂起的逻辑</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 拿到锁之后干什么？</span>
                <span class="token comment" spellcheck="true">// 首先设置自己为 head节点</span>
                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 将前置节点的 next 引用置为nul。协助出队。</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>
                <span class="token comment" spellcheck="true">// 当前线程获取锁的过程中没有出现异常</span>
                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 返回当前线程的中断标记</span>
                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// shouldParkAfterFailedAcquire </span>
            <span class="token comment" spellcheck="true">// 表示当前线程获取锁资源失败了是否需要挂起呢？</span>
            <span class="token comment" spellcheck="true">// 返回值：true-> 当前线程需要挂起  false-> 不需要..</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token comment" spellcheck="true">//parkAndCheckInterrupt</span>
                <span class="token comment" spellcheck="true">//挂起当前线程，并且唤醒之后 返回 当前线程的中断标记</span>
                <span class="token comment" spellcheck="true">//唤醒：1.正常唤醒 其他线程 unpark 2.其他线程给当前挂起的线程一个中断信号</span>
                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="竞争逻辑"><a href="#竞争逻辑" class="headerlink" title="竞争逻辑"></a>竞争逻辑</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获取前置节点的状态 （前面有写，建议翻看）</span>
    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 成立：前置节点是可以唤醒当前节点的，返回 true 后，parkAndCheckInterrupt park当前线程</span>
    <span class="token comment" spellcheck="true">// 普通情况下，第一次来到 该方法 ws 不会是 -1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ws > 0 表示前置节点是 CANCELED 状态</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 唤醒 canceled 节点的条件是当前节点的前置节点的 ws 为-1</span>
        <span class="token comment" spellcheck="true">// 那么这个 do while 循环就不断地向前找状态不大于 0 的节点</span>
        <span class="token comment" spellcheck="true">// 那么 ws > 0 的节点会出队（下面有图，可以参考一下）</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果当前 node 前置节点的状态为 0，</span>
        <span class="token comment" spellcheck="true">// 则会将当前线程 node 前置节点状态强制设置为 SINGNAL</span>
        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>总结：</p>
<ol>
<li>当前节点的前置节点是取消状态，第一次来到这个方法时会越过取消状态的节点，第二次会返回 true，然后 park 当前线程。</li>
<li>当前节点的前置节点状态是 0，当前线程会设置前置节点的状态为 -1，第二次自旋来到这个方法时，会返回true 然后 Park 当前线程。</li>
</ol>
<p>接下来是 parkAndCheckInterrupt（）</p>
<p>它是 AQS 的方法，park 当前线程 将当前线程挂起，唤醒后返回当前线程是否为中断信号唤醒。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="通篇总结"><a href="#通篇总结" class="headerlink" title="通篇总结"></a>通篇总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是这篇文章的全部内容了，最后在概述一遍做个总结吧，主要是想梳理一下所有的源码知识点，毕竟无论是面试还是与人讨论我们都要大致说一下，总不能上来就滴水不漏地将整体细节全部描述出来。</p>
<p>① 如果我们用的是公平锁，那么我们就要调用FairSync 的 lock() 。</p>
<p>② 然后 lock 调用 acquire，参数传入 1，设置 AQS的 state 的值。</p>
<p>③ 进入 acquire 我们首先要尝试拿到锁（tryAcquire）,怎么去尝试拿到锁呢？我们先是获取当前线程，通过当前线程获取当前线程的状态值（state），如果状态值为 0，说明现在是无锁状态。然后判断当前线程前面有没有线程在等待（hasQueuedPredecessors），如果没有那么就通过 cas 的方式去设置 state值（compareAndSetState）。如果设置 state 值成功了，说明我们抢占锁成功了。把当前线程设置成独占者线程（setExclusiveOwnerThread），然后就返回 true 了。如果锁重入了呢，更新 state 值，再次设置新的 state，最后返回 true;</p>
<p>④ 如果没有拿到锁，那么我们会将当前线程封装成一个 Node 节点，然后将这个节点添加到阻塞队列中。</p>
<p>⑤进入到阻塞队列中我们还要看看当前线程是否是 park 状态，如果不是那么就将其挂起。并且唤醒线程的逻辑也在这个方法里。但唤醒的逻辑要下次再讲。到此整个加锁的过程全部完成。</p>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>以上文献资料来自 B 站 ”<strong>小刘思源码</strong>“，在此感谢小刘老师。</p>
]]></content>
      <categories>
        <category>AQS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 持久化</title>
    <url>/2020/12/26/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>从所周知，Redis 的数据全部放在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 <strong>Redis 的持久化机制</strong>。</p>
<p>Redis 有两种持久化方式：一种为 <strong>RDB 方式</strong>，RDB 保存某一个时间点之前的数据；另一种为 <strong>AFO 方式</strong>，AOF保存的是 Redis 服务器端执行的每一条命令。</p>
<h3 id="快照-RDB"><a href="#快照-RDB" class="headerlink" title="快照 RDB"></a>快照 RDB</h3><p>RDB 快照有两种触发方式，其一<strong>通过配置参数</strong>，例如在配置文件中写入如下配置：</p>
<blockquote>
<p>save  60  1000</p>
</blockquote>
<p>在 60 秒内如果有 1000 个 key 发生变化，就会触发一次 RDB 快照的执行。</p>
<p>其二是<strong>通过在客户端执行 bgsave 命令</strong> 显式触发一次 RDB 快照执行。（下图为 bgsave 的执行流程）                </p>
<img src="/images/redis/redis1/r1.png" style="zoom:30%;">                        

<blockquote>
<p>SAVE  命令也可以用于生成 RDB 文件，不同的是 SASVE 会阻塞 Redis 服务器进程，直至 RDB 文件创建完毕</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们需要关注的问题是，在内存数据做快照时，这些数据还能被修改吗？如果我们在拍照片时被拍对象”动“了，那么我们拍到的照片是模糊的。假如一次快照时间是 20s，在时刻 t 给内存做快照。而在时刻 t + 5 时，一个还没被写入磁盘的内存数据 A 被修改为 B，那么就破坏了快照的完整性，因为 B 不是 t 时刻的状态。因此，和拍照类似，我们在做快照时不希望数据 ”动“，也就是不能被修改。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可是如果在快照的时间里，Redis 不能处理这些数据的写操作，那么无疑会给业务服务造成巨大的影响，肯定是不能接受的。所以这个时候，Redis 就会如上图所示 fork 出一个子进程执行 rdbSave 函数进行实际的快照存储工作。其原理是借助操作系统提供的写时复制技术 （Copy On Write），在执行快照的同时，正常处理写操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么主线程和 bgsave 子进程相互不影响。但是如果主线程要修改一块数据，这个时候就会使用操作系统的 COW 机制来进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离开来，然后对这个复制的页面进行修改。这时子进程相应的页面时没有变化的，还是进程产生的那一瞬间的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RDB 保存的是一个时间点的快照，那么如果 Redis 出现了故障，丢失的就是最后一次 RDB 执行的时间点到故障发生的时间间隔之内之内产生的数据。如果 Redis 数据量很大，QPS 很高，那么故障发生时丢失的数据也会增多。那么如何解决这个由 RDB 本质引发的问题呢？请往下看。</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AOF 就是将 Redis 服务端执行过的每一条命令都保存到一个文件，这样当Redis 重启时只要按照顺序回放这些命令就会恢复到原始状态。而 AOF 保存的是一条条命令，理论上可以做到发生故障时只丢失一条命令。那么如何开启 AOF 呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们要修改 Redis 的配置文件 <strong>redis.conf</strong>，找到 <strong>appendonly</strong>，将该值的 no 该写为 yes。退出后重启 Redis，就会发现 Redis bin 目录下有一个 appendonly.aof 文件，证明 AOF 持久化开启成功。</p>
<p><strong>AOF 日志是由主线程来完成的。</strong></p>
<p>下图为 AOF  持久化的过程。</p>
<img src="/images/redis/redis1/aof1.png" style="zoom:50%;">    

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 AOF 持久化功能处于打开状态时，服务器在执行一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。aof_buf 是个全局的 SDS 类型的缓冲区。AOF 持久化最终需要将缓冲区中的内容写入一个文件，也就是 AOF 写入。</p>
<h4 id="AOF-文件写入"><a href="#AOF-文件写入" class="headerlink" title="AOF 文件写入"></a>AOF 文件写入</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写文件通过操作系统提供的 write 函数执行。但是 write 之后数据只是保存在 kernel 的缓冲区，真正写入磁盘还需要调用 fsync 函数。fsync 是一个阻塞并且缓慢的操作，所以 Redis 通过 appendfsync 配置控制执行 fsync 的频率。具体有如下 3 种写回策略。</p>
<ul>
<li>no：不执行 fsync，由操作系统负责数据的刷盘。数据安全性最低但 Redis 性能最高。</li>
<li>always：每次执行写入就会执行一次 fsync。数据安全性最高但会导致 Redis 性能降低。</li>
<li>everysec：每 1 秒执行一次 fsync 操作。属于折中方案，在数据安全和性能之间达到一个平衡。</li>
</ul>
<p>生产环境一般配置为 <strong>appendfsync  everysec</strong>。下面是三种写回策略的图片总结，方便大家理解。</p>
<img src="/images/redis/redis1/aof3.png" style="zoom:50%;">

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们以 Redis 收到”set testkey  testvalue“ 命令后记录的日志为例，看看 AOF 日志的内容。其中，”*3“ 表示当前命令有三个部分，每部分都是由”$ + 数字“ 开头。例如，”$3 set“  表示这部分有3个字节，也就是”set” 命令；”$7 testkey“ 表示这部分有 7 个字节，也就是 ”testkey“ 等等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上解决 AOF 从命令追加到写入 AOF 日志文件，但是随着 Redis 使用频率的增加，我们可能会进行大量的操作，那么就会有大量的命令。大量的命令会使 AOF 日志文件增大，并且随着 AOF 文件的增大，读取日志文件的时间也会拉长。针对这个问题，我们便推出了一个新的概念 <strong>AOF 重写</strong>。</p>
<h4 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h4><p>AOF 重写通过主线程 <strong>fork</strong> 出一个子进程 bgerwriteaof 来执行。就是将多条命令变为一条命令，例如：</p>
<p>6379&gt; rpush list 1 2 3</p>
<p>(Integer) 3</p>
<p>6379&gt;  rpush list 4           // list 中 增加 4</p>
<p>(integer) 4 </p>
<p>6379&gt;  rpush  list  5         // list 中增加 5</p>
<p>(integer) 5</p>
<p>6379&gt;  lpop   list               // 弹出第一个元素</p>
<p>那么 AOF 会保存对 list 操作的 4 条命令</p>
<p>6379&gt; lrange list 0  -1          // 输出 list 中所有元素</p>
<p>4 条命令变为一条命令，可以减小文件大小，又可以提高加载速度。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而fork 出一个子进程来执行的目的是创建一个新 AOF 文件的任务会进行大量的写入操作，会长时间阻塞主线程，而在这期间可能无法处理客户端发来的命令请求。这是 Redis 所不希望的，因此重写操作会交给子进程来执行。（在 fork 的一瞬间也是会阻塞主线程的。）</p>
<h4 id="AOF-重写触发方式"><a href="#AOF-重写触发方式" class="headerlink" title="AOF 重写触发方式"></a>AOF 重写触发方式</h4><p>有两种触发方式：一是<strong>通过配置自动触发</strong>，一种为<strong>手动执行 bgrewriteaof 命令显式触发</strong>。首先来看自动触发方式。</p>
<blockquote>
<p>auto-aof-rewrite-percentage    100</p>
<p>auto-aof-rewrite-min-size   64mb</p>
</blockquote>
<p>解释：当 AOF 文件大于 64MB 时，并且 AOF 文件当前大小比基准大小增长了 100% 时会触发一次 AOF 重写。通常啊，生产上会将 auto-aof-rewrite-min-size 至少设置为 5G 左右。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重写日志出现问题就扔了。 重写日志的时候新的写命令会在缓冲区里面，等到重写完成了会发送信号给主线程，然后把缓冲区日志写到重写日志里面，就可以以新换旧了。由此可见，AOF 通过重写解决了文件膨胀的问题。随后，Redis 服务器可以创建一个新的 AOF 文件来替换现有的 AOF 文件。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，使用子进程也有一个问题需要处理，因为子进程在进行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对数据库状态进行修改。从而使得服务器当前的数据库状态和重写后的数据库状态不一致。 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这种数据不一致问题，Redis 服务器设置了一个 AOF 重写缓冲区，如下图所示。</p>
<h4 id="AOF-后台重写"><a href="#AOF-后台重写" class="headerlink" title="AOF 后台重写"></a>AOF 后台重写</h4><p>在子进程执行 AOF 重写期间，服务器进程需要执行以下三个工作：</p>
<ul>
<li><p>执行客户端发来的命令</p>
</li>
<li><p>将执行后的命令追加到 AOF 缓冲区</p>
</li>
<li><p>在 fork 子进程的同时会把主线程的内存拷贝一份给 begrewriteaof 子进程。（这里的拷贝不是物理内存，而是子进程复制了父进程的页表，即虚实映射关系。fork 采用了操作系统系统的写时复制机制，就是为了避免一次性拷贝大量内存数据给子进程造成长时间阻塞问题。）</p>
</li>
</ul>
<p>当子进程完全 AOF 重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后会调用一个信号处理函数，并执行以下工作：</p>
<p>1）将 AOF  重写缓冲区中的所有内容写到新的 AOF 文件中，这时新 AOF 文件所保存的数据库状态和服务器当前的数据库状态一致。</p>
<p>2）对新的 AOF 文件进行改名，原子地覆盖所有的 AOF  文件，完成信就两个 AOF 文件的替换。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>到这里 Redis 持久化就给大家总结完了，如果有什么讲的不仔细的可以给我提意见，我会认真修改的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《Redis 设计与实现》—黄建宏 著</p>
<p>《Redis 5设计与源码分析》—- 陈雷 等编著</p>
<p>极客时间（Redis 核心技术与实战）</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2020/12/29/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-Spring-事务（20201229）"><a href="#1-Spring-事务（20201229）" class="headerlink" title="1. Spring 事务（20201229）"></a>1. Spring 事务（20201229）</h3><h4 id="1-1-Spring-事务中的隔离级别有哪几种？"><a href="#1-1-Spring-事务中的隔离级别有哪几种？" class="headerlink" title="1.1 Spring 事务中的隔离级别有哪几种？"></a>1.1 Spring 事务中的隔离级别有哪几种？</h4><ul>
<li>TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，Mysql 默认采用 REPEATABLE_READ 隔离级别，Oracle 默认采用的 READ_COMMITTED 隔离级别。</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、欢度或不可重复读</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复度仍可能发生</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事物之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这样将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h4 id="1-2-Spring-事务传播机制类型"><a href="#1-2-Spring-事务传播机制类型" class="headerlink" title="1.2 Spring 事务传播机制类型"></a>1.2 Spring 事务传播机制类型</h4><p>① PROPAGATION_REQUIRED</p>
<ul>
<li>支持当前事务，如果当前没有事务，则新建事务</li>
<li>如果当前存在事务，则加入当前事务，合并成一个事务</li>
</ul>
<p>② REQUIRES_NEW</p>
<ul>
<li>新建事务，如果当前存在事务，则把当前事务挂起</li>
<li>不受调用者的事物影响，父级异常，它也是正常提交</li>
</ul>
<p>③ SUPPORTS</p>
<ul>
<li>如果当前存在事务，则加入事务</li>
<li>不存在事务，则以非事务方式运行</li>
</ul>
<p>④ NOT_SUPPORTED</p>
<ul>
<li>以非事务方式运行</li>
<li>如果当前存在事务，则把当前事务挂起</li>
</ul>
<p>⑤ MANDATORY</p>
<ul>
<li>如果当前存在事务，则运行在当前事务中</li>
<li>如果当前无事务，则抛出异常，即父级方法必须有事务</li>
</ul>
<p>⑥ NEVER</p>
<ul>
<li>以非事务方式运行，如果当前存在事务，则抛出异常，即父级方法必须无事务</li>
</ul>
<p>⑦ NESTED</p>
<ul>
<li><p>如果当前存在事务，他会将成为父级事物的一个子事务，方法结束后并没有提交，只有等父事务结束了才提交</p>
</li>
<li><p>如果当前没事务，则新建事务</p>
</li>
<li><p>如果它异常，父级可以捕获它的异常而不进行混滚，正常提交</p>
</li>
</ul>
<p>参考：<a href="https://segmentfault.com/a/1190000020386113?utm_source=tag-newest">https://segmentfault.com/a/1190000020386113?utm_source=tag-newest</a></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
