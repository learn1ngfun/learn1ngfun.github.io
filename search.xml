<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>重入锁 ReentrantLock 源码浅析（二）</title>
    <url>/2020/12/18/ReentrantLock2/</url>
    <content><![CDATA[<p>上篇文章主要讲了 ReentrantLock 的加锁和入队内容，今天我们来聊一聊释放锁和出队的内容。顺便带一下非公平锁，直接进入主题。</p>
<h3 id="AQS-释放锁逻辑"><a href="#AQS-释放锁逻辑" class="headerlink" title="AQS 释放锁逻辑"></a>AQS 释放锁逻辑</h3><h4 id="release-int-arg"><a href="#release-int-arg" class="headerlink" title="release(int arg)"></a>release(int arg)</h4><p>释放锁的调用关系</p>
<p>ReentrantLock.unpark() —&gt; sync.release() —&gt; AQS 提供的 relsese</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//尝试释放锁，为 true,则表示完全释放锁。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// head 什么时候会被创建出来</span>
      <span class="token comment" spellcheck="true">// 当前线程未释放线程时，且持锁期间，有其他线程想要获取锁时，其他线程发现获取不到锁，</span>
      <span class="token comment" spellcheck="true">// 而且队列是空队列，此时后续线程会为当前持锁中的线程构建出来一个 head 节点，</span>
      <span class="token comment" spellcheck="true">// 然后后续线程会追加到 head 节点后面。</span>
      Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 条件一：成立，说明队列中的head节点已经初始化过了，ReentrantLock 在使用期间发生过多线程竞争</span>
      <span class="token comment" spellcheck="true">// 条件二：成立，说明当前head 后面一定插入过节点</span>
      <span class="token comment" spellcheck="true">//（head 当开始初始化的时候是0，但是后面如果有节点插入则会将当前head节点的 ws 修改为 -1）</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">// 唤醒后继节点</span>
        <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 减去释放的值..</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 如果当前线程并未持锁，直接异常。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 当前线程持有锁</span>
    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是否已经完全释放锁</span>
    <span class="token comment" spellcheck="true">// 只有当前线程的 state 值为 0，才是完全释放锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> free<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="unparkSuccessor-Node-node"><a href="#unparkSuccessor-Node-node" class="headerlink" title="unparkSuccessor(Node node)"></a>unparkSuccessor(Node node)</h4><p>AQS 中的 unparkSuccessor。</p>
<p>唤醒当前节点的下一个节点。</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 改成 0 的原因：因为当前节点已经完成唤醒后继节点的任务了。</span>
            <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 当前节点的第一个后继节点</span>
        Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/*
         *什么时候 s 等于 null 呢
         *1.当前节点就是 tail 节点时
         *2.当节点未入队完成时
         *  重述一遍入队过程：
         *    ① 设置新节点的 prev 指向 pred
         *    ② cas 这只新节点为 tail
         *    ③ Pred.next 指向新节点（此处未完成）
         *  当 ③ 还未完成时当前节点调用 release, 那么你拿到的 node.next 为 Null
         *需要找到可以唤醒的节点
         */</span>
          <span class="token comment" spellcheck="true">//接下来看条件二</span>
        <span class="token comment" spellcheck="true">//如果进入条件二，那么说明 s != null</span>
        <span class="token comment" spellcheck="true">//说明 s 节点为取消状态，那么需要找一个合适的可以被唤醒的节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 查找可以被唤醒的节点</span>
            s <span class="token operator">=</span> null<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 从队尾遍历，会找到一个离当前 node 最近的一个可以被唤醒的 node，</span>
            <span class="token comment" spellcheck="true">// node 可能找不到，node 可能是 null</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    s <span class="token operator">=</span> t<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果找到合适的可以被唤醒的 node，则唤醒..找不到 什么也不做。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span>
            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 总的来说一下上面三个方法。首先如果我们调用 ReentrantLock 的 unpark 方法，实际上我们就是调用 AQS的 release 方法。在 release 方法里我们首先会去尝试释放锁，什么时候算完全释放锁呢，当前线程的 state = 0的时候。如果当前 state 值为 0，那么如果当前线程不是空并且不是尾节点的话我们就会尝试唤醒后继节点。去阻塞队列里找到距离当前节点最近的，并且唤醒 waitStatus 小于等于 0 的节点。以上就是释放锁的大体逻辑。</p>
<h3 id="AQS-响应中断出队"><a href="#AQS-响应中断出队" class="headerlink" title="AQS 响应中断出队"></a>AQS 响应中断出队</h3><h4 id="cancelAcquire-Node-node"><a href="#cancelAcquire-Node-node" class="headerlink" title="cancelAcquire(Node node)"></a>cancelAcquire(Node node)</h4><p>取消指定 node 参与竞争</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 因为已经取消排队了，所以 node 内部关联的当前线程，置为 NULL 就好了</span>
    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>
    Node pred <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
      node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    Node predNext <span class="token operator">=</span> pred<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 将当前node 状态设置为 取消状态 1</span>
    node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> Node<span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/*
     * 当前取消排队的node 所在队列的位置不同，执行的出队策略是不一样的，一共分为三种情况：
     * 1.当前 node 是队尾  tail -> node
     * 2.当前 node 不是 head.next 节点，也不是 tail
     * 3.当前 node 是 head.next 节点
     */</span>
    <span class="token comment" spellcheck="true">//条件一： node == tail  当前 Node 是队尾</span>
    <span class="token comment" spellcheck="true">//条件二： 成功的话，说明修改 tail 完成</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 如果当前node 是队尾的话肯定要将 node 与前继节点断开然后尾指针指向前继节点</span>
      <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">int</span> ws<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 当前 node 不是 head.next 节点，也不是 tail</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> head <span class="token operator">&amp;&amp;</span>
          <span class="token comment" spellcheck="true">// 条件2.1：成立，说明 node 的前驱状态是 signal 状态</span>
          <span class="token comment" spellcheck="true">//         不成立：前驱状态可能是 0 ，也可能是 1（前驱也取消排队..）</span>
          <span class="token comment" spellcheck="true">// 条件2.2：假设前驱状态 &lt;= 0，则设置前驱状态为 Signal 状态..表示要唤醒后继节点。</span>
          <span class="token comment" spellcheck="true">//if 里面：就是让 pred.next -> node.next，所以需要保证 pred 节点状态为 signal 状态</span>
          <span class="token punctuation">(</span><span class="token punctuation">(</span>ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">)</span> <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL <span class="token operator">||</span>
           <span class="token punctuation">(</span>ws <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
          pred<span class="token punctuation">.</span>thread <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 出队：pred.next -> node.next 节点后，当 node.next 节点被唤醒后</span>
        <span class="token comment" spellcheck="true">// 调用 shouldParkAfterFailedAcquire 会让 node.next 节点越过取消状态的节点</span>
        <span class="token comment" spellcheck="true">// 完成真正出队</span>
        Node next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> next<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
          <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">//当前 node 是 head.next 节点</span>
        <span class="token comment" spellcheck="true">// 后继节点唤醒后，会调用 shouldParkAfterFailedAcquire 会让 node.next 节点越过取消状态的节点</span>
        <span class="token comment" spellcheck="true">// 队列的第三个节点 会 直接与 head 建立 双重指向的关系：head.next -> 第三个 node 中间就是被出队                 //的 head.next 第三个 node.prev -> head(下面有简图)</span>
        <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">// 指向自己，出队</span>
      node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<img src="C:\Users\MrZhang\AppData\Roaming\Typora\typora-user-images\image-20201214212403096.png" alt="image-20201214212403096" style="zoom:0%;" />



<h3 id="AQS-非公平锁"><a href="#AQS-非公平锁" class="headerlink" title="AQS 非公平锁"></a>AQS 非公平锁</h3><p>顺带说几嘴非公平锁，如果你理解了公平锁，非公平锁只是稍有不同。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 7316153563782823691L<span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 上来就尝试加锁，也不管队列里有没有其他线程在等待，也不管当前状态有没有加锁。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// 抢占成功设置独占</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果当前状态为0，它还是不判断当前队列里是否有等待线程，直接尝试抢锁</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 没成功查看有没有重入</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 接下来都一样，该入队列入队列，该抢占资源抢占资源</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所以，非公平与公平锁就两点区别：① lock 的时候会先尝试抢一下锁，拿不到 调用 tryAquire；② 抢锁时都不去判断队列里是否有等待线程。其他流程一样。非公平锁时默认情况下的一种策略。</p>
<p>至此，AQS 的 ReentrantLock 的源码就分析完成了，</p>
]]></content>
      <categories>
        <category>AQS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>重入锁 ReentrantLock 源码浅析（一）</title>
    <url>/2020/12/12/ReentrantLock/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 除了使用关键字 synchronized 外，还使用了 ReentrantLock 实现独占、可重入锁的功能。相较于 synchronized，ReentrantLock 更为丰富和灵活。除此之外，我们或多或少还听说过一个名词 AQS。AQS 是Java 提供的底层同步工具，用一个 int 类型的变量表示同步状态，提供一系列的 CAS 操作来管理这个同步状态。我们今天的主角 ReentrantLock 也是基于 AQS 实现的。好的，废话少说，我们开始源码的探索路程。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先啊，我们打开源码就看到了 ReentrantLock 实现了 Lock 接口，那么 Lock 里面的一些加锁啊解锁啊等方法自然也要一一实现。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable </code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实ReentrantLock 就一个属性，那就是 sync。但 ReentrantLock 自己实现了一个 Sync 的静态内部类。这个 Sync 继承了 AbstractQueuedSynchronizer，也就是我们常说的 AQS。所以 AQS 中的一些重要属性自然而然也被ReentrantLock 继承。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进入 AbstractQueuedSynchronizer，我们依然可以看到里面也实现了一个静态内部类 Node。这个 Node 至关重要，它会出现在接下来的所有内容中。这次我只列举了ReentrantLock 需要用到的属性。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/** Marker to indicate a node is waiting in shared mode */</span>
        <span class="token comment" spellcheck="true">/** 共享模式 */</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> Node SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** Marker to indicate a node is waiting in exclusive mode */</span>
        <span class="token comment" spellcheck="true">/** 独占模式 */</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> Node EXCLUSIVE <span class="token operator">=</span> null<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/** waitStatus value to indicate thread has cancelled */</span>
        <span class="token comment" spellcheck="true">/** 表示当前节点处于 取消 状态 */</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** waitStatus value to indicate successor's thread needs unparking */</span>
        <span class="token comment" spellcheck="true">/** 表示当前节点需要唤醒后继节点 */</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** node 节点的状态 */</span>
        <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** 因为需要构建双想链表，所以 prev 表示指向 node 节点的前一个节点*/</span>
        <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** 指向 node 节点的后继节点*/</span>
        <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** node 封装的线程 */</span>
        <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/** 阻塞队列的头节点 头节点对应的都是当前线程*/</span>
        <span class="token comment" spellcheck="true">/** 这里的 head 并不是阻塞队列双向链表的 head，可以把 head.next 当做阻塞队列的开始
         *  我在这里就犯了迷糊，在空队列的定义上犹豫了一会，所以这里给大家提个醒。 
         */</span>
        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/**
         * Tail of the wait queue, lazily initialized.  Modified only via
         * method enq to add new wait node.
         */</span>
        <span class="token comment" spellcheck="true">/** 阻塞队列的尾节点 */</span>
        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/**
         * The synchronization state.
         */</span>
        <span class="token comment" spellcheck="true">// 表示资源</span>
        <span class="token comment" spellcheck="true">// 独占模式：0 表示未加锁状态，>0 表示加锁状态</span>
        <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReentrantLock 里面需要用到的属性就大致讲完了，其实还有一个状态码为 0 的，它代表当前节点是新建的节点。哦，对了，AbstractQueuedSynchronizer 还继承了一个抽象类 AbstractOwnableSynchronizer，里面的exclusiveOwnerThread 属性及其 get、set 方法也是重点对象。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 独占锁模式：表示当前独占锁线程</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> Thread exclusiveOwnerThread<span class="token punctuation">;</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     exclusiveOwnerThread <span class="token operator">=</span> thread<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> Thread <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> exclusiveOwnerThread<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>介绍完属性，接下来开始进入源码的阅读，这次主讲公平锁。先大致列举一下加锁阶段的方法。</p>
<p>lock()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt;acquire() 竞争资源</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; tryAquire() 尝试获取锁</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; acquireQueued()  挂起当前线程</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; shouldParkAfterFailedAcquire()// 当前线程获取锁资源失败后是否需要挂起呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true: 需要；  false  不需要</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; parkAndCheckInterrupt()  挂起当前线程，唤醒之后返回当前线程的中断标记</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| –&gt; addWaiter()将当前线程封装成node</p>
<p>OK，大致骨架梳理完了，源码开始，gogogogo!!</p>
<h3 id="acquire-int-arg-–-加锁"><a href="#acquire-int-arg-–-加锁" class="headerlink" title="acquire(int arg) – 加锁"></a>acquire(int arg) – 加锁</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 公平锁入口，不响应中断的加锁</span>
<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 尝试获取锁，成功返回 true，失败返回 false.</span>
    <span class="token comment" spellcheck="true">/* addWaiter 将当前线程封装成 node 入队
     * acquireQueued 挂起当前线程 
     *               返回 true 表示挂起过程中线程被中断唤醒过
     *                                返回 false 表示未被中断过
     */</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
       <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，acquire() 就是竞争资源的方法，首先回去尝试获取锁，成功了就执行其业务逻辑，不成功会将其包装成Node进入阻塞队列中并挂起。</p>
<h3 id="tryAcquire-int-acquires-–-尝试获取锁"><a href="#tryAcquire-int-acquires-–-尝试获取锁" class="headerlink" title="tryAcquire(int acquires) – 尝试获取锁"></a>tryAcquire(int acquires) – 尝试获取锁</h3><pre class=" language-java"><code class="language-java">
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获取当前线程</span>
    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// AQS state</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// state == 0 表示当前 AQS 处于无锁状态</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * 条件1：hasQueuedPredecessors() 
         *       true：当前线程前面有等待者，当前线程需要入队等待
         *       false：当前线程前面无等待者，直接尝试获取锁
         * 条件2：通过 CAS 的方式设置 state
         *       success：当前线程抢占锁成功
         *       fail：存在竞争，且当前线程竞争失败
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//设置当前线程为独占者 线程</span>
            <span class="token comment" spellcheck="true">// 注意：这里没有设置阻塞队列的 head 节点，后续在分析 addWaiter 的 enq 会提到</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// c != 0 需要检查当前线程是不是 独占锁的线程，因为ReentrantLock 是可重入的</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 更新值</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 越界判断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 1.CAS 失败  c == 0 时，CAS 修改 sate时未抢过其他线程</span>
    <span class="token comment" spellcheck="true">// 2. c > 0 且 ownerThread != currentThread.</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到 acquire方法，tryAcquire 如果返回 true 取反后为 false，就返回业务层面了。可如果tryAcquire 为 false，取反后为 true，那么就要进入阻塞队列挂起了。接下来我们看一下 addWaiter()。</p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 将当前节点封装到 node 中</span>
    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// Try the fast path of enq; backup to full enq on failure</span>
    Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 快速入队</span>
    <span class="token comment" spellcheck="true">// 条件成立：表示队列里面有 node</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将node 的 prev 指向 pred</span>
        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 通过 cas 的方式将 node 入队</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 前置节点指向 node，完成双向绑定。</span>
            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 什么时候会执行到这里？</span>
    <span class="token comment" spellcheck="true">//1. 当前队列是空队列 tail == null</span>
    <span class="token comment" spellcheck="true">//2. cas 竞争入队失败</span>

    <span class="token comment" spellcheck="true">// 完整入队</span>
    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，addWaiter 方法无非就是将当前线程封装成 node节点加入到阻塞队列队尾中。如果一切进展顺利即上面所说的“快速入队”。如果中间出现阻塞队列为空队列或者 cas 插入队尾失败的情况则进入完整入队。接下来我们分析一下完整入队 enq()。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/** 自旋入队，只有当前 node 入队成功后，才会跳出循环*/</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/*
         * 队列为空队列
         * 说明当前锁 被占用，且当前线程有可能是第一个获取锁失败的线程
         * （为什么是有可能？因为当前时刻可能存在一批获取锁失败的线程.）
         */</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Must initialize</span>
            <span class="token comment" spellcheck="true">// 作为当前持锁线程的第一个后继线程</span>
            <span class="token comment" spellcheck="true">// 1.因为当前持锁线程在获取锁时（tryAcquire），成功了，并没有向阻塞队列中添加</span>
            <span class="token comment" spellcheck="true">//   任何元素,所以这里要通过 cas 方式给阻塞队列添加头节点。</span>
            <span class="token comment" spellcheck="true">// 2.自己追加节点</span>
            <span class="token comment" spellcheck="true">// 然后我们便开始进入下一轮循环，下一轮直接进入 else</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 由于阻塞队列中已经有我们之前创建的节点了，所以我们直接将node的 prev指向 tail</span>
            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 通过cas的方式将当前 node 设置成新的尾节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
                <span class="token keyword">return</span> t<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全入队也很好理解，其实就是主要解决 addWaiter 没有入队成功的情况。如果你是因为空队列入队失败，那么我们就自己创建一个头节点，如果你是由于 cas 竞争入队失败，那么我们就自选入队直至成功。</p>
<p>接下来是 acquireQueued() 了，我个人认为这个方法有点烦的，我会尽量复述清楚。</p>
<p>这里先简单梳理一下 acquireQueued 的骨架。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;acquireQueued</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; shouldParkAfterFailedAcquire</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–&gt; parkAndCheckInterrupt</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| –&gt; cancelAcquire</p>
<p>acquireQueued 做了什么呢？</p>
<ol>
<li>当前节点是否有被 park？ 没有，那么就挂起。</li>
<li>唤醒之后的逻辑。</li>
</ol>
<p>当然了，这个方法依然是 AQS的，两个参数分别代表：</p>
<p>   参数1：node 就是当前线程包装出来的 node，且当前时刻 已经入队成功..</p>
<p>   参数2：当前线程抢占资源成功后，设置 state 值时会用到。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// true 表示当前线程抢占锁成功，普通情况下【lock】 当前线程早晚会拿到锁</span>
    <span class="token comment" spellcheck="true">// false 表示失败，需要执行出队操作</span>
    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 当前线程是否会中断</span>
        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//自旋</span>
            <span class="token comment" spellcheck="true">// 什么时候会执行这里呢 </span>
            <span class="token comment" spellcheck="true">//1.进入 for 循环时，在线程尚未 park 前会执行</span>
            <span class="token comment" spellcheck="true">//2.线程 park 之后被唤醒后，也会执行这里..</span>
            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取当期线程的前置节点</span>
            <span class="token comment" spellcheck="true">//条件一：成立 则说明当前节点为 head.next 节点，head.next 节点在任何时候都有权去争夺锁</span>
            <span class="token comment" spellcheck="true">//条件二：tryAcquire(arg)</span>
            <span class="token comment" spellcheck="true">//成立：说明head对应的线程已经释放锁了，head.next 节点对应的线程正好取到锁</span>
            <span class="token comment" spellcheck="true">//不成立：说明 head 对应的线程还没释放锁，head.next 仍然需要被park。然后又走到下面挂起的逻辑</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 拿到锁之后干什么？</span>
                <span class="token comment" spellcheck="true">// 首先设置自己为 head节点</span>
                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 将前置节点的 next 引用置为nul。协助出队。</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>
                <span class="token comment" spellcheck="true">// 当前线程获取锁的过程中没有出现异常</span>
                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 返回当前线程的中断标记</span>
                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// shouldParkAfterFailedAcquire </span>
            <span class="token comment" spellcheck="true">// 表示当前线程获取锁资源失败了是否需要挂起呢？</span>
            <span class="token comment" spellcheck="true">// 返回值：true-> 当前线程需要挂起  false-> 不需要..</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token comment" spellcheck="true">//parkAndCheckInterrupt</span>
                <span class="token comment" spellcheck="true">//挂起当前线程，并且唤醒之后 返回 当前线程的中断标记</span>
                <span class="token comment" spellcheck="true">//唤醒：1.正常唤醒 其他线程 unpark 2.其他线程给当前挂起的线程一个中断信号</span>
                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="竞争逻辑"><a href="#竞争逻辑" class="headerlink" title="竞争逻辑"></a>竞争逻辑</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获取前置节点的状态 （前面有写，建议翻看）</span>
    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 成立：前置节点是可以唤醒当前节点的，返回 true 后，parkAndCheckInterrupt park当前线程</span>
    <span class="token comment" spellcheck="true">// 普通情况下，第一次来到 该方法 ws 不会是 -1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ws > 0 表示前置节点是 CANCELED 状态</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 唤醒 canceled 节点的条件是当前节点的前置节点的 ws 为-1</span>
        <span class="token comment" spellcheck="true">// 那么这个 do while 循环就不断地向前找状态不大于 0 的节点</span>
        <span class="token comment" spellcheck="true">// 那么 ws > 0 的节点会出队（下面有图，可以参考一下）</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果当前 node 前置节点的状态为 0，</span>
        <span class="token comment" spellcheck="true">// 则会将当前线程 node 前置节点状态强制设置为 SINGNAL</span>
        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>总结：</p>
<ol>
<li>当前节点的前置节点是取消状态，第一次来到这个方法时会越过取消状态的节点，第二次会返回 true，然后 park 当前线程。</li>
<li>当前节点的前置节点状态是 0，当前线程会设置前置节点的状态为 -1，第二次自旋来到这个方法时，会返回true 然后 Park 当前线程。</li>
</ol>
<p>接下来是 parkAndCheckInterrupt（）</p>
<p>它是 AQS 的方法，park 当前线程 将当前线程挂起，唤醒后返回当前线程是否为中断信号唤醒。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="通篇总结"><a href="#通篇总结" class="headerlink" title="通篇总结"></a>通篇总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是这篇文章的全部内容了，最后在概述一遍做个总结吧，主要是想梳理一下所有的源码知识点，毕竟无论是面试还是与人讨论我们都要大致说一下，总不能上来就滴水不漏地将整体细节全部描述出来。</p>
<p>① 如果我们用的是公平锁，那么我们就要调用FairSync 的 lock() 。</p>
<p>② 然后 lock 调用 acquire，参数传入 1，设置 AQS的 state 的值。</p>
<p>③ 进入 acquire 我们首先要尝试拿到锁（tryAcquire）,怎么去尝试拿到锁呢？我们先是获取当前线程，通过当前线程获取当前线程的状态值（state），如果状态值为 0，说明现在是无锁状态。然后判断当前线程前面有没有线程在等待（hasQueuedPredecessors），如果没有那么就通过 cas 的方式去设置 state值（compareAndSetState）。如果设置 state 值成功了，说明我们抢占锁成功了。把当前线程设置成独占者线程（setExclusiveOwnerThread），然后就返回 true 了。如果锁重入了呢，更新 state 值，再次设置新的 state，最后返回 true;</p>
<p>④ 如果没有拿到锁，那么我们会将当前线程封装成一个 Node 节点，然后将这个节点添加到阻塞队列中。</p>
<p>⑤进入到阻塞队列中我们还要看看当前线程是否是 park 状态，如果不是那么就将其挂起。并且唤醒线程的逻辑也在这个方法里。但唤醒的逻辑要下次再讲。到此整个加锁的过程全部完成。</p>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>以上文献资料来自 B 站 ”<strong>小刘思源码</strong>“，在此感谢小刘老师。</p>
]]></content>
      <categories>
        <category>AQS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
